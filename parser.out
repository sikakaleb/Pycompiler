Grammar:

Rule 0     S' -> statement
Rule 1     statement -> prog
Rule 2     prog -> listeInstructions
Rule 3     listeInstructions -> instruction
Rule 4     listeInstructions -> listeInstructions instruction
Rule 5     instruction -> fonction_declaration
Rule 6     instruction -> appel_fonction_1
Rule 7     instruction -> appel_fonction_2
Rule 8     instruction -> retourner
Rule 9     instruction -> boucle
Rule 10    instruction -> condition
Rule 11    instruction -> affectation
Rule 12    instruction -> declaration
Rule 13    instruction -> ecrire
Rule 14    ecrire -> ECRIRE ( expr ) ;
Rule 15    declaration -> type IDENTIFIANT = expr ;
Rule 16    affectation -> IDENTIFIANT = expr ;
Rule 17    condition -> SI ( expr ) { listeInstructions } suite_sinosi
Rule 18    suite_sinosi -> <empty>
Rule 19    suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi
Rule 20    suite_sinosi -> SINON { listeInstructions }
Rule 21    boucle -> TANTQUE ( expr ) { listeInstructions }
Rule 22    retourner -> RETOURNER expr ;
Rule 23    retourner -> retourner
Rule 24    appel_fonction_2 -> IDENTIFIANT ( ) ;
Rule 25    appel_fonction_1 -> IDENTIFIANT ( )
Rule 26    fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions }
Rule 27    factor -> LIRE ( )
Rule 28    factor -> MINUS expr  [precedence=nonassoc, level=2]
Rule 29    factor -> NON expr  [precedence=nonassoc, level=1]
Rule 30    factor -> factor OU expr  [precedence=left, level=6]
Rule 31    factor -> factor ET expr  [precedence=left, level=5]
Rule 32    factor -> IDENTIFIANT
Rule 33    factor -> ( expr )
Rule 34    factor -> BOOLEEN_LITERAL
Rule 35    factor -> ENTIER
Rule 36    expr -> expr COMPARATEUR expr  [precedence=nonassoc, level=7]
Rule 37    expr -> term
Rule 38    expr -> expr MINUS term  [precedence=left, level=4]
Rule 39    expr -> expr PLUS term  [precedence=left, level=4]
Rule 40    term -> factor
Rule 41    term -> term MODULO factor  [precedence=left, level=3]
Rule 42    term -> term DIV factor  [precedence=left, level=3]
Rule 43    term -> term MULT factor  [precedence=left, level=3]
Rule 44    term -> appel_fonction_1
Rule 45    type -> ENT
Rule 46    type -> BOOLEEN

Unused terminals:

    ALORS
    UMINUS

Terminals, with rules where they appear:

(                    : 14 17 19 21 24 25 26 27 33
)                    : 14 17 19 21 24 25 26 27 33
;                    : 14 15 16 22 24
=                    : 15 16
ALORS                : 
BOOLEEN              : 46
BOOLEEN_LITERAL      : 34
COMPARATEUR          : 36
DIV                  : 42
ECRIRE               : 14
ENT                  : 45
ENTIER               : 35
ET                   : 31
IDENTIFIANT          : 15 16 24 25 26 32
LIRE                 : 27
MINUS                : 28 38
MODULO               : 41
MULT                 : 43
NON                  : 29
OU                   : 30
PLUS                 : 39
RETOURNER            : 22
SI                   : 17 19
SINON                : 19 20
TANTQUE              : 21
UMINUS               : 
error                : 
{                    : 17 19 20 21 26
}                    : 17 19 20 21 26

Nonterminals, with rules where they appear:

affectation          : 11
appel_fonction_1     : 6 44
appel_fonction_2     : 7
boucle               : 9
condition            : 10
declaration          : 12
ecrire               : 13
expr                 : 14 15 16 17 19 21 22 28 29 30 31 33 36 36 38 39
factor               : 30 31 40 41 42 43
fonction_declaration : 5
instruction          : 3 4
listeInstructions    : 2 4 17 19 20 21 26
prog                 : 1
retourner            : 8 23
statement            : 0
suite_sinosi         : 17 19
term                 : 37 38 39 41 42 43
type                 : 15 26


state 0

    (0) S' -> . statement
    (1) statement -> . prog
    (2) prog -> . listeInstructions
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    statement                      shift and go to state 1
    prog                           shift and go to state 2
    listeInstructions              shift and go to state 3
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 1

    (0) S' -> statement .


state 2

    (1) statement -> prog .
    $end            reduce using rule 1 (statement -> prog .)


state 3

    (2) prog -> listeInstructions .
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    $end            reduce using rule 2 (prog -> listeInstructions .)
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    instruction                    shift and go to state 22
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 4

    (3) listeInstructions -> instruction .
    IDENTIFIANT     reduce using rule 3 (listeInstructions -> instruction .)
    RETOURNER       reduce using rule 3 (listeInstructions -> instruction .)
    TANTQUE         reduce using rule 3 (listeInstructions -> instruction .)
    SI              reduce using rule 3 (listeInstructions -> instruction .)
    ECRIRE          reduce using rule 3 (listeInstructions -> instruction .)
    ENT             reduce using rule 3 (listeInstructions -> instruction .)
    BOOLEEN         reduce using rule 3 (listeInstructions -> instruction .)
    $end            reduce using rule 3 (listeInstructions -> instruction .)
    }               reduce using rule 3 (listeInstructions -> instruction .)


state 5

    (5) instruction -> fonction_declaration .
    IDENTIFIANT     reduce using rule 5 (instruction -> fonction_declaration .)
    RETOURNER       reduce using rule 5 (instruction -> fonction_declaration .)
    TANTQUE         reduce using rule 5 (instruction -> fonction_declaration .)
    SI              reduce using rule 5 (instruction -> fonction_declaration .)
    ECRIRE          reduce using rule 5 (instruction -> fonction_declaration .)
    ENT             reduce using rule 5 (instruction -> fonction_declaration .)
    BOOLEEN         reduce using rule 5 (instruction -> fonction_declaration .)
    $end            reduce using rule 5 (instruction -> fonction_declaration .)
    }               reduce using rule 5 (instruction -> fonction_declaration .)


state 6

    (6) instruction -> appel_fonction_1 .
    IDENTIFIANT     reduce using rule 6 (instruction -> appel_fonction_1 .)
    RETOURNER       reduce using rule 6 (instruction -> appel_fonction_1 .)
    TANTQUE         reduce using rule 6 (instruction -> appel_fonction_1 .)
    SI              reduce using rule 6 (instruction -> appel_fonction_1 .)
    ECRIRE          reduce using rule 6 (instruction -> appel_fonction_1 .)
    ENT             reduce using rule 6 (instruction -> appel_fonction_1 .)
    BOOLEEN         reduce using rule 6 (instruction -> appel_fonction_1 .)
    $end            reduce using rule 6 (instruction -> appel_fonction_1 .)
    }               reduce using rule 6 (instruction -> appel_fonction_1 .)


state 7

    (7) instruction -> appel_fonction_2 .
    IDENTIFIANT     reduce using rule 7 (instruction -> appel_fonction_2 .)
    RETOURNER       reduce using rule 7 (instruction -> appel_fonction_2 .)
    TANTQUE         reduce using rule 7 (instruction -> appel_fonction_2 .)
    SI              reduce using rule 7 (instruction -> appel_fonction_2 .)
    ECRIRE          reduce using rule 7 (instruction -> appel_fonction_2 .)
    ENT             reduce using rule 7 (instruction -> appel_fonction_2 .)
    BOOLEEN         reduce using rule 7 (instruction -> appel_fonction_2 .)
    $end            reduce using rule 7 (instruction -> appel_fonction_2 .)
    }               reduce using rule 7 (instruction -> appel_fonction_2 .)


state 8

    (8) instruction -> retourner .
    (23) retourner -> retourner .
  ! reduce/reduce conflict for IDENTIFIANT resolved using rule 8 (instruction -> retourner .)
  ! reduce/reduce conflict for RETOURNER resolved using rule 8 (instruction -> retourner .)
  ! reduce/reduce conflict for TANTQUE resolved using rule 8 (instruction -> retourner .)
  ! reduce/reduce conflict for SI resolved using rule 8 (instruction -> retourner .)
  ! reduce/reduce conflict for ECRIRE resolved using rule 8 (instruction -> retourner .)
  ! reduce/reduce conflict for ENT resolved using rule 8 (instruction -> retourner .)
  ! reduce/reduce conflict for BOOLEEN resolved using rule 8 (instruction -> retourner .)
  ! reduce/reduce conflict for $end resolved using rule 8 (instruction -> retourner .)
  ! reduce/reduce conflict for } resolved using rule 8 (instruction -> retourner .)
    IDENTIFIANT     reduce using rule 8 (instruction -> retourner .)
    RETOURNER       reduce using rule 8 (instruction -> retourner .)
    TANTQUE         reduce using rule 8 (instruction -> retourner .)
    SI              reduce using rule 8 (instruction -> retourner .)
    ECRIRE          reduce using rule 8 (instruction -> retourner .)
    ENT             reduce using rule 8 (instruction -> retourner .)
    BOOLEEN         reduce using rule 8 (instruction -> retourner .)
    $end            reduce using rule 8 (instruction -> retourner .)
    }               reduce using rule 8 (instruction -> retourner .)


state 9

    (9) instruction -> boucle .
    IDENTIFIANT     reduce using rule 9 (instruction -> boucle .)
    RETOURNER       reduce using rule 9 (instruction -> boucle .)
    TANTQUE         reduce using rule 9 (instruction -> boucle .)
    SI              reduce using rule 9 (instruction -> boucle .)
    ECRIRE          reduce using rule 9 (instruction -> boucle .)
    ENT             reduce using rule 9 (instruction -> boucle .)
    BOOLEEN         reduce using rule 9 (instruction -> boucle .)
    $end            reduce using rule 9 (instruction -> boucle .)
    }               reduce using rule 9 (instruction -> boucle .)


state 10

    (10) instruction -> condition .
    IDENTIFIANT     reduce using rule 10 (instruction -> condition .)
    RETOURNER       reduce using rule 10 (instruction -> condition .)
    TANTQUE         reduce using rule 10 (instruction -> condition .)
    SI              reduce using rule 10 (instruction -> condition .)
    ECRIRE          reduce using rule 10 (instruction -> condition .)
    ENT             reduce using rule 10 (instruction -> condition .)
    BOOLEEN         reduce using rule 10 (instruction -> condition .)
    $end            reduce using rule 10 (instruction -> condition .)
    }               reduce using rule 10 (instruction -> condition .)


state 11

    (11) instruction -> affectation .
    IDENTIFIANT     reduce using rule 11 (instruction -> affectation .)
    RETOURNER       reduce using rule 11 (instruction -> affectation .)
    TANTQUE         reduce using rule 11 (instruction -> affectation .)
    SI              reduce using rule 11 (instruction -> affectation .)
    ECRIRE          reduce using rule 11 (instruction -> affectation .)
    ENT             reduce using rule 11 (instruction -> affectation .)
    BOOLEEN         reduce using rule 11 (instruction -> affectation .)
    $end            reduce using rule 11 (instruction -> affectation .)
    }               reduce using rule 11 (instruction -> affectation .)


state 12

    (12) instruction -> declaration .
    IDENTIFIANT     reduce using rule 12 (instruction -> declaration .)
    RETOURNER       reduce using rule 12 (instruction -> declaration .)
    TANTQUE         reduce using rule 12 (instruction -> declaration .)
    SI              reduce using rule 12 (instruction -> declaration .)
    ECRIRE          reduce using rule 12 (instruction -> declaration .)
    ENT             reduce using rule 12 (instruction -> declaration .)
    BOOLEEN         reduce using rule 12 (instruction -> declaration .)
    $end            reduce using rule 12 (instruction -> declaration .)
    }               reduce using rule 12 (instruction -> declaration .)


state 13

    (13) instruction -> ecrire .
    IDENTIFIANT     reduce using rule 13 (instruction -> ecrire .)
    RETOURNER       reduce using rule 13 (instruction -> ecrire .)
    TANTQUE         reduce using rule 13 (instruction -> ecrire .)
    SI              reduce using rule 13 (instruction -> ecrire .)
    ECRIRE          reduce using rule 13 (instruction -> ecrire .)
    ENT             reduce using rule 13 (instruction -> ecrire .)
    BOOLEEN         reduce using rule 13 (instruction -> ecrire .)
    $end            reduce using rule 13 (instruction -> ecrire .)
    }               reduce using rule 13 (instruction -> ecrire .)


state 14

    (26) fonction_declaration -> type . IDENTIFIANT ( ) { listeInstructions }
    (15) declaration -> type . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 23


state 15

    (25) appel_fonction_1 -> IDENTIFIANT . ( )
    (24) appel_fonction_2 -> IDENTIFIANT . ( ) ;
    (16) affectation -> IDENTIFIANT . = expr ;
    (               shift and go to state 24
    =               shift and go to state 25


state 16

    (22) retourner -> RETOURNER . expr ;
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 26
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 17

    (21) boucle -> TANTQUE . ( expr ) { listeInstructions }
    (               shift and go to state 37


state 18

    (17) condition -> SI . ( expr ) { listeInstructions } suite_sinosi
    (               shift and go to state 38


state 19

    (14) ecrire -> ECRIRE . ( expr ) ;
    (               shift and go to state 39


state 20

    (45) type -> ENT .
    IDENTIFIANT     reduce using rule 45 (type -> ENT .)


state 21

    (46) type -> BOOLEEN .
    IDENTIFIANT     reduce using rule 46 (type -> BOOLEEN .)


state 22

    (4) listeInstructions -> listeInstructions instruction .
    IDENTIFIANT     reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    RETOURNER       reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    TANTQUE         reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    SI              reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    ECRIRE          reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    ENT             reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    BOOLEEN         reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    $end            reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    }               reduce using rule 4 (listeInstructions -> listeInstructions instruction .)


state 23

    (26) fonction_declaration -> type IDENTIFIANT . ( ) { listeInstructions }
    (15) declaration -> type IDENTIFIANT . = expr ;
    (               shift and go to state 40
    =               shift and go to state 41


state 24

    (25) appel_fonction_1 -> IDENTIFIANT ( . )
    (24) appel_fonction_2 -> IDENTIFIANT ( . ) ;
    )               shift and go to state 42


state 25

    (16) affectation -> IDENTIFIANT = . expr ;
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 43
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 26

    (22) retourner -> RETOURNER expr . ;
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    ;               shift and go to state 44
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 27

    (37) expr -> term .
    (41) term -> term . MODULO factor
    (42) term -> term . DIV factor
    (43) term -> term . MULT factor
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
    ;               reduce using rule 37 (expr -> term .)
    COMPARATEUR     reduce using rule 37 (expr -> term .)
    MINUS           reduce using rule 37 (expr -> term .)
    PLUS            reduce using rule 37 (expr -> term .)
    OU              reduce using rule 37 (expr -> term .)
    ET              reduce using rule 37 (expr -> term .)
    )               reduce using rule 37 (expr -> term .)
    MODULO          shift and go to state 48
    DIV             shift and go to state 49
    MULT            shift and go to state 50


state 28

    (28) factor -> MINUS . expr
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 51
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 29

    (40) term -> factor .
    (30) factor -> factor . OU expr
    (31) factor -> factor . ET expr
  ! shift/reduce conflict for OU resolved as shift
  ! shift/reduce conflict for ET resolved as shift
    MODULO          reduce using rule 40 (term -> factor .)
    DIV             reduce using rule 40 (term -> factor .)
    MULT            reduce using rule 40 (term -> factor .)
    ;               reduce using rule 40 (term -> factor .)
    COMPARATEUR     reduce using rule 40 (term -> factor .)
    MINUS           reduce using rule 40 (term -> factor .)
    PLUS            reduce using rule 40 (term -> factor .)
    )               reduce using rule 40 (term -> factor .)
    OU              shift and go to state 52
    ET              shift and go to state 53


state 30

    (44) term -> appel_fonction_1 .
    MODULO          reduce using rule 44 (term -> appel_fonction_1 .)
    DIV             reduce using rule 44 (term -> appel_fonction_1 .)
    MULT            reduce using rule 44 (term -> appel_fonction_1 .)
    ;               reduce using rule 44 (term -> appel_fonction_1 .)
    COMPARATEUR     reduce using rule 44 (term -> appel_fonction_1 .)
    MINUS           reduce using rule 44 (term -> appel_fonction_1 .)
    PLUS            reduce using rule 44 (term -> appel_fonction_1 .)
    OU              reduce using rule 44 (term -> appel_fonction_1 .)
    ET              reduce using rule 44 (term -> appel_fonction_1 .)
    )               reduce using rule 44 (term -> appel_fonction_1 .)


state 31

    (27) factor -> LIRE . ( )
    (               shift and go to state 54


state 32

    (33) factor -> ( . expr )
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 55
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 33

    (29) factor -> NON . expr
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 56
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 34

    (32) factor -> IDENTIFIANT .
    (25) appel_fonction_1 -> IDENTIFIANT . ( )
    OU              reduce using rule 32 (factor -> IDENTIFIANT .)
    ET              reduce using rule 32 (factor -> IDENTIFIANT .)
    MODULO          reduce using rule 32 (factor -> IDENTIFIANT .)
    DIV             reduce using rule 32 (factor -> IDENTIFIANT .)
    MULT            reduce using rule 32 (factor -> IDENTIFIANT .)
    ;               reduce using rule 32 (factor -> IDENTIFIANT .)
    COMPARATEUR     reduce using rule 32 (factor -> IDENTIFIANT .)
    MINUS           reduce using rule 32 (factor -> IDENTIFIANT .)
    PLUS            reduce using rule 32 (factor -> IDENTIFIANT .)
    )               reduce using rule 32 (factor -> IDENTIFIANT .)
    (               shift and go to state 57


state 35

    (34) factor -> BOOLEEN_LITERAL .
    OU              reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    ET              reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    MODULO          reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    DIV             reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    MULT            reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    ;               reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    COMPARATEUR     reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    MINUS           reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    PLUS            reduce using rule 34 (factor -> BOOLEEN_LITERAL .)
    )               reduce using rule 34 (factor -> BOOLEEN_LITERAL .)


state 36

    (35) factor -> ENTIER .
    OU              reduce using rule 35 (factor -> ENTIER .)
    ET              reduce using rule 35 (factor -> ENTIER .)
    MODULO          reduce using rule 35 (factor -> ENTIER .)
    DIV             reduce using rule 35 (factor -> ENTIER .)
    MULT            reduce using rule 35 (factor -> ENTIER .)
    ;               reduce using rule 35 (factor -> ENTIER .)
    COMPARATEUR     reduce using rule 35 (factor -> ENTIER .)
    MINUS           reduce using rule 35 (factor -> ENTIER .)
    PLUS            reduce using rule 35 (factor -> ENTIER .)
    )               reduce using rule 35 (factor -> ENTIER .)


state 37

    (21) boucle -> TANTQUE ( . expr ) { listeInstructions }
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 58
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 38

    (17) condition -> SI ( . expr ) { listeInstructions } suite_sinosi
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 59
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 39

    (14) ecrire -> ECRIRE ( . expr ) ;
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 60
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 40

    (26) fonction_declaration -> type IDENTIFIANT ( . ) { listeInstructions }
    )               shift and go to state 61


state 41

    (15) declaration -> type IDENTIFIANT = . expr ;
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 62
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 42

    (25) appel_fonction_1 -> IDENTIFIANT ( ) .
    (24) appel_fonction_2 -> IDENTIFIANT ( ) . ;
    IDENTIFIANT     reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    RETOURNER       reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    TANTQUE         reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    SI              reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    ECRIRE          reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    ENT             reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    BOOLEEN         reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    $end            reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    }               reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    ;               shift and go to state 63


state 43

    (16) affectation -> IDENTIFIANT = expr . ;
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    ;               shift and go to state 64
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 44

    (22) retourner -> RETOURNER expr ; .
    IDENTIFIANT     reduce using rule 22 (retourner -> RETOURNER expr ; .)
    RETOURNER       reduce using rule 22 (retourner -> RETOURNER expr ; .)
    TANTQUE         reduce using rule 22 (retourner -> RETOURNER expr ; .)
    SI              reduce using rule 22 (retourner -> RETOURNER expr ; .)
    ECRIRE          reduce using rule 22 (retourner -> RETOURNER expr ; .)
    ENT             reduce using rule 22 (retourner -> RETOURNER expr ; .)
    BOOLEEN         reduce using rule 22 (retourner -> RETOURNER expr ; .)
    $end            reduce using rule 22 (retourner -> RETOURNER expr ; .)
    }               reduce using rule 22 (retourner -> RETOURNER expr ; .)


state 45

    (36) expr -> expr COMPARATEUR . expr
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 65
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 46

    (38) expr -> expr MINUS . term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    term                           shift and go to state 66
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 47

    (39) expr -> expr PLUS . term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    term                           shift and go to state 67
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 48

    (41) term -> term MODULO . factor
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 69
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    factor                         shift and go to state 68

state 49

    (42) term -> term DIV . factor
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 69
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    factor                         shift and go to state 70

state 50

    (43) term -> term MULT . factor
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 69
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    factor                         shift and go to state 71

state 51

    (28) factor -> MINUS expr .
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    OU              reduce using rule 28 (factor -> MINUS expr .)
    ET              reduce using rule 28 (factor -> MINUS expr .)
    MODULO          reduce using rule 28 (factor -> MINUS expr .)
    DIV             reduce using rule 28 (factor -> MINUS expr .)
    MULT            reduce using rule 28 (factor -> MINUS expr .)
    ;               reduce using rule 28 (factor -> MINUS expr .)
    )               reduce using rule 28 (factor -> MINUS expr .)
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 52

    (30) factor -> factor OU . expr
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    factor                         shift and go to state 29
    expr                           shift and go to state 72
    term                           shift and go to state 27
    appel_fonction_1               shift and go to state 30

state 53

    (31) factor -> factor ET . expr
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    factor                         shift and go to state 29
    expr                           shift and go to state 73
    term                           shift and go to state 27
    appel_fonction_1               shift and go to state 30

state 54

    (27) factor -> LIRE ( . )
    )               shift and go to state 74


state 55

    (33) factor -> ( expr . )
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    )               shift and go to state 75
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 56

    (29) factor -> NON expr .
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    OU              reduce using rule 29 (factor -> NON expr .)
    ET              reduce using rule 29 (factor -> NON expr .)
    MODULO          reduce using rule 29 (factor -> NON expr .)
    DIV             reduce using rule 29 (factor -> NON expr .)
    MULT            reduce using rule 29 (factor -> NON expr .)
    ;               reduce using rule 29 (factor -> NON expr .)
    )               reduce using rule 29 (factor -> NON expr .)
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 57

    (25) appel_fonction_1 -> IDENTIFIANT ( . )
    )               shift and go to state 76


state 58

    (21) boucle -> TANTQUE ( expr . ) { listeInstructions }
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    )               shift and go to state 77
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 59

    (17) condition -> SI ( expr . ) { listeInstructions } suite_sinosi
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    )               shift and go to state 78
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 60

    (14) ecrire -> ECRIRE ( expr . ) ;
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    )               shift and go to state 79
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 61

    (26) fonction_declaration -> type IDENTIFIANT ( ) . { listeInstructions }
    {               shift and go to state 80


state 62

    (15) declaration -> type IDENTIFIANT = expr . ;
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    ;               shift and go to state 81
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 63

    (24) appel_fonction_2 -> IDENTIFIANT ( ) ; .
    IDENTIFIANT     reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)
    RETOURNER       reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)
    TANTQUE         reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)
    SI              reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)
    ECRIRE          reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)
    ENT             reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)
    BOOLEEN         reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)
    $end            reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)
    }               reduce using rule 24 (appel_fonction_2 -> IDENTIFIANT ( ) ; .)


state 64

    (16) affectation -> IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)
    RETOURNER       reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)
    TANTQUE         reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)
    SI              reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)
    ENT             reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)
    }               reduce using rule 16 (affectation -> IDENTIFIANT = expr ; .)


state 65

    (36) expr -> expr COMPARATEUR expr .
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    ;               reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    COMPARATEUR     reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    MINUS           reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    PLUS            reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    OU              reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    ET              reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    MODULO          reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    DIV             reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    MULT            reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    )               reduce using rule 36 (expr -> expr COMPARATEUR expr .)


state 66

    (38) expr -> expr MINUS term .
    (41) term -> term . MODULO factor
    (42) term -> term . DIV factor
    (43) term -> term . MULT factor
    ;               reduce using rule 38 (expr -> expr MINUS term .)
    COMPARATEUR     reduce using rule 38 (expr -> expr MINUS term .)
    MINUS           reduce using rule 38 (expr -> expr MINUS term .)
    PLUS            reduce using rule 38 (expr -> expr MINUS term .)
    OU              reduce using rule 38 (expr -> expr MINUS term .)
    ET              reduce using rule 38 (expr -> expr MINUS term .)
    MODULO          reduce using rule 38 (expr -> expr MINUS term .)
    DIV             reduce using rule 38 (expr -> expr MINUS term .)
    MULT            reduce using rule 38 (expr -> expr MINUS term .)
    )               reduce using rule 38 (expr -> expr MINUS term .)


state 67

    (39) expr -> expr PLUS term .
    (41) term -> term . MODULO factor
    (42) term -> term . DIV factor
    (43) term -> term . MULT factor
    ;               reduce using rule 39 (expr -> expr PLUS term .)
    COMPARATEUR     reduce using rule 39 (expr -> expr PLUS term .)
    MINUS           reduce using rule 39 (expr -> expr PLUS term .)
    PLUS            reduce using rule 39 (expr -> expr PLUS term .)
    OU              reduce using rule 39 (expr -> expr PLUS term .)
    ET              reduce using rule 39 (expr -> expr PLUS term .)
    MODULO          reduce using rule 39 (expr -> expr PLUS term .)
    DIV             reduce using rule 39 (expr -> expr PLUS term .)
    MULT            reduce using rule 39 (expr -> expr PLUS term .)
    )               reduce using rule 39 (expr -> expr PLUS term .)


state 68

    (41) term -> term MODULO factor .
    (30) factor -> factor . OU expr
    (31) factor -> factor . ET expr
    MODULO          reduce using rule 41 (term -> term MODULO factor .)
    DIV             reduce using rule 41 (term -> term MODULO factor .)
    MULT            reduce using rule 41 (term -> term MODULO factor .)
    ;               reduce using rule 41 (term -> term MODULO factor .)
    COMPARATEUR     reduce using rule 41 (term -> term MODULO factor .)
    MINUS           reduce using rule 41 (term -> term MODULO factor .)
    PLUS            reduce using rule 41 (term -> term MODULO factor .)
    )               reduce using rule 41 (term -> term MODULO factor .)
    OU              shift and go to state 52
    ET              shift and go to state 53


state 69

    (32) factor -> IDENTIFIANT .
    COMPARATEUR     reduce using rule 32 (factor -> IDENTIFIANT .)
    MINUS           reduce using rule 32 (factor -> IDENTIFIANT .)
    PLUS            reduce using rule 32 (factor -> IDENTIFIANT .)
    OU              reduce using rule 32 (factor -> IDENTIFIANT .)
    ET              reduce using rule 32 (factor -> IDENTIFIANT .)
    MODULO          reduce using rule 32 (factor -> IDENTIFIANT .)
    DIV             reduce using rule 32 (factor -> IDENTIFIANT .)
    MULT            reduce using rule 32 (factor -> IDENTIFIANT .)
    ;               reduce using rule 32 (factor -> IDENTIFIANT .)
    )               reduce using rule 32 (factor -> IDENTIFIANT .)


state 70

    (42) term -> term DIV factor .
    (30) factor -> factor . OU expr
    (31) factor -> factor . ET expr
    MODULO          reduce using rule 42 (term -> term DIV factor .)
    DIV             reduce using rule 42 (term -> term DIV factor .)
    MULT            reduce using rule 42 (term -> term DIV factor .)
    ;               reduce using rule 42 (term -> term DIV factor .)
    COMPARATEUR     reduce using rule 42 (term -> term DIV factor .)
    MINUS           reduce using rule 42 (term -> term DIV factor .)
    PLUS            reduce using rule 42 (term -> term DIV factor .)
    )               reduce using rule 42 (term -> term DIV factor .)
    OU              shift and go to state 52
    ET              shift and go to state 53


state 71

    (43) term -> term MULT factor .
    (30) factor -> factor . OU expr
    (31) factor -> factor . ET expr
    MODULO          reduce using rule 43 (term -> term MULT factor .)
    DIV             reduce using rule 43 (term -> term MULT factor .)
    MULT            reduce using rule 43 (term -> term MULT factor .)
    ;               reduce using rule 43 (term -> term MULT factor .)
    COMPARATEUR     reduce using rule 43 (term -> term MULT factor .)
    MINUS           reduce using rule 43 (term -> term MULT factor .)
    PLUS            reduce using rule 43 (term -> term MULT factor .)
    )               reduce using rule 43 (term -> term MULT factor .)
    OU              shift and go to state 52
    ET              shift and go to state 53


state 72

    (30) factor -> factor OU expr .
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    OU              reduce using rule 30 (factor -> factor OU expr .)
    ET              reduce using rule 30 (factor -> factor OU expr .)
    MODULO          reduce using rule 30 (factor -> factor OU expr .)
    DIV             reduce using rule 30 (factor -> factor OU expr .)
    MULT            reduce using rule 30 (factor -> factor OU expr .)
    ;               reduce using rule 30 (factor -> factor OU expr .)
    MINUS           reduce using rule 30 (factor -> factor OU expr .)
    PLUS            reduce using rule 30 (factor -> factor OU expr .)
    )               reduce using rule 30 (factor -> factor OU expr .)
    COMPARATEUR     shift and go to state 45


state 73

    (31) factor -> factor ET expr .
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    OU              reduce using rule 31 (factor -> factor ET expr .)
    ET              reduce using rule 31 (factor -> factor ET expr .)
    MODULO          reduce using rule 31 (factor -> factor ET expr .)
    DIV             reduce using rule 31 (factor -> factor ET expr .)
    MULT            reduce using rule 31 (factor -> factor ET expr .)
    ;               reduce using rule 31 (factor -> factor ET expr .)
    MINUS           reduce using rule 31 (factor -> factor ET expr .)
    PLUS            reduce using rule 31 (factor -> factor ET expr .)
    )               reduce using rule 31 (factor -> factor ET expr .)
    COMPARATEUR     shift and go to state 45


state 74

    (27) factor -> LIRE ( ) .
    OU              reduce using rule 27 (factor -> LIRE ( ) .)
    ET              reduce using rule 27 (factor -> LIRE ( ) .)
    MODULO          reduce using rule 27 (factor -> LIRE ( ) .)
    DIV             reduce using rule 27 (factor -> LIRE ( ) .)
    MULT            reduce using rule 27 (factor -> LIRE ( ) .)
    ;               reduce using rule 27 (factor -> LIRE ( ) .)
    COMPARATEUR     reduce using rule 27 (factor -> LIRE ( ) .)
    MINUS           reduce using rule 27 (factor -> LIRE ( ) .)
    PLUS            reduce using rule 27 (factor -> LIRE ( ) .)
    )               reduce using rule 27 (factor -> LIRE ( ) .)


state 75

    (33) factor -> ( expr ) .
    OU              reduce using rule 33 (factor -> ( expr ) .)
    ET              reduce using rule 33 (factor -> ( expr ) .)
    MODULO          reduce using rule 33 (factor -> ( expr ) .)
    DIV             reduce using rule 33 (factor -> ( expr ) .)
    MULT            reduce using rule 33 (factor -> ( expr ) .)
    ;               reduce using rule 33 (factor -> ( expr ) .)
    COMPARATEUR     reduce using rule 33 (factor -> ( expr ) .)
    MINUS           reduce using rule 33 (factor -> ( expr ) .)
    PLUS            reduce using rule 33 (factor -> ( expr ) .)
    )               reduce using rule 33 (factor -> ( expr ) .)


state 76

    (25) appel_fonction_1 -> IDENTIFIANT ( ) .
    MODULO          reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    DIV             reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    MULT            reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    ;               reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    COMPARATEUR     reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    MINUS           reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    PLUS            reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    OU              reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    ET              reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)
    )               reduce using rule 25 (appel_fonction_1 -> IDENTIFIANT ( ) .)


state 77

    (21) boucle -> TANTQUE ( expr ) . { listeInstructions }
    {               shift and go to state 82


state 78

    (17) condition -> SI ( expr ) . { listeInstructions } suite_sinosi
    {               shift and go to state 83


state 79

    (14) ecrire -> ECRIRE ( expr ) . ;
    ;               shift and go to state 84


state 80

    (26) fonction_declaration -> type IDENTIFIANT ( ) { . listeInstructions }
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    type                           shift and go to state 14
    listeInstructions              shift and go to state 85
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13

state 81

    (15) declaration -> type IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)
    RETOURNER       reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)
    TANTQUE         reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)
    SI              reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)
    ENT             reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)
    $end            reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)
    }               reduce using rule 15 (declaration -> type IDENTIFIANT = expr ; .)


state 82

    (21) boucle -> TANTQUE ( expr ) { . listeInstructions }
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    listeInstructions              shift and go to state 86
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 83

    (17) condition -> SI ( expr ) { . listeInstructions } suite_sinosi
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    listeInstructions              shift and go to state 87
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 84

    (14) ecrire -> ECRIRE ( expr ) ; .
    IDENTIFIANT     reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)
    RETOURNER       reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)
    TANTQUE         reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)
    SI              reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)
    ENT             reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)
    BOOLEEN         reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)
    }               reduce using rule 14 (ecrire -> ECRIRE ( expr ) ; .)


state 85

    (26) fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions . }
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    }               shift and go to state 88
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    type                           shift and go to state 14
    instruction                    shift and go to state 22
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13

state 86

    (21) boucle -> TANTQUE ( expr ) { listeInstructions . }
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    }               shift and go to state 89
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    instruction                    shift and go to state 22
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 87

    (17) condition -> SI ( expr ) { listeInstructions . } suite_sinosi
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    }               shift and go to state 90
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    instruction                    shift and go to state 22
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 88

    (26) fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .
    IDENTIFIANT     reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)
    RETOURNER       reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)
    TANTQUE         reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)
    SI              reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)
    ECRIRE          reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)
    ENT             reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)
    BOOLEEN         reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)
    $end            reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)
    }               reduce using rule 26 (fonction_declaration -> type IDENTIFIANT ( ) { listeInstructions } .)


state 89

    (21) boucle -> TANTQUE ( expr ) { listeInstructions } .
    IDENTIFIANT     reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    RETOURNER       reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    TANTQUE         reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    SI              reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    ECRIRE          reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    ENT             reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    BOOLEEN         reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    $end            reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    }               reduce using rule 21 (boucle -> TANTQUE ( expr ) { listeInstructions } .)


state 90

    (17) condition -> SI ( expr ) { listeInstructions } . suite_sinosi
    (18) suite_sinosi -> .
    (19) suite_sinosi -> . SINON SI ( expr ) { listeInstructions } suite_sinosi
    (20) suite_sinosi -> . SINON { listeInstructions }
    IDENTIFIANT     reduce using rule 18 (suite_sinosi -> .)
    RETOURNER       reduce using rule 18 (suite_sinosi -> .)
    TANTQUE         reduce using rule 18 (suite_sinosi -> .)
    SI              reduce using rule 18 (suite_sinosi -> .)
    ECRIRE          reduce using rule 18 (suite_sinosi -> .)
    ENT             reduce using rule 18 (suite_sinosi -> .)
    BOOLEEN         reduce using rule 18 (suite_sinosi -> .)
    $end            reduce using rule 18 (suite_sinosi -> .)
    }               reduce using rule 18 (suite_sinosi -> .)
    SINON           shift and go to state 92

    suite_sinosi                   shift and go to state 91

state 91

    (17) condition -> SI ( expr ) { listeInstructions } suite_sinosi .
    IDENTIFIANT     reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    RETOURNER       reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    TANTQUE         reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    SI              reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    ECRIRE          reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    ENT             reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    BOOLEEN         reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    $end            reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    }               reduce using rule 17 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)


state 92

    (19) suite_sinosi -> SINON . SI ( expr ) { listeInstructions } suite_sinosi
    (20) suite_sinosi -> SINON . { listeInstructions }
    SI              shift and go to state 93
    {               shift and go to state 94


state 93

    (19) suite_sinosi -> SINON SI . ( expr ) { listeInstructions } suite_sinosi
    (               shift and go to state 95


state 94

    (20) suite_sinosi -> SINON { . listeInstructions }
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    listeInstructions              shift and go to state 96
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 95

    (19) suite_sinosi -> SINON SI ( . expr ) { listeInstructions } suite_sinosi
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . term
    (38) expr -> . expr MINUS term
    (39) expr -> . expr PLUS term
    (40) term -> . factor
    (41) term -> . term MODULO factor
    (42) term -> . term DIV factor
    (43) term -> . term MULT factor
    (44) term -> . appel_fonction_1
    (27) factor -> . LIRE ( )
    (28) factor -> . MINUS expr
    (29) factor -> . NON expr
    (30) factor -> . factor OU expr
    (31) factor -> . factor ET expr
    (32) factor -> . IDENTIFIANT
    (33) factor -> . ( expr )
    (34) factor -> . BOOLEEN_LITERAL
    (35) factor -> . ENTIER
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    LIRE            shift and go to state 31
    MINUS           shift and go to state 28
    NON             shift and go to state 33
    IDENTIFIANT     shift and go to state 34
    (               shift and go to state 32
    BOOLEEN_LITERAL shift and go to state 35
    ENTIER          shift and go to state 36

    expr                           shift and go to state 97
    term                           shift and go to state 27
    factor                         shift and go to state 29
    appel_fonction_1               shift and go to state 30

state 96

    (20) suite_sinosi -> SINON { listeInstructions . }
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    }               shift and go to state 98
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    instruction                    shift and go to state 22
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 97

    (19) suite_sinosi -> SINON SI ( expr . ) { listeInstructions } suite_sinosi
    (36) expr -> expr . COMPARATEUR expr
    (38) expr -> expr . MINUS term
    (39) expr -> expr . PLUS term
    )               shift and go to state 99
    COMPARATEUR     shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47


state 98

    (20) suite_sinosi -> SINON { listeInstructions } .
    IDENTIFIANT     reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)
    RETOURNER       reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)
    TANTQUE         reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)
    SI              reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)
    ECRIRE          reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)
    ENT             reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)
    BOOLEEN         reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)
    $end            reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)
    }               reduce using rule 20 (suite_sinosi -> SINON { listeInstructions } .)


state 99

    (19) suite_sinosi -> SINON SI ( expr ) . { listeInstructions } suite_sinosi
    {               shift and go to state 100


state 100

    (19) suite_sinosi -> SINON SI ( expr ) { . listeInstructions } suite_sinosi
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    listeInstructions              shift and go to state 101
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 101

    (19) suite_sinosi -> SINON SI ( expr ) { listeInstructions . } suite_sinosi
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . appel_fonction_1
    (7) instruction -> . appel_fonction_2
    (8) instruction -> . retourner
    (9) instruction -> . boucle
    (10) instruction -> . condition
    (11) instruction -> . affectation
    (12) instruction -> . declaration
    (13) instruction -> . ecrire
    (26) fonction_declaration -> . type IDENTIFIANT ( ) { listeInstructions }
    (25) appel_fonction_1 -> . IDENTIFIANT ( )
    (24) appel_fonction_2 -> . IDENTIFIANT ( ) ;
    (22) retourner -> . RETOURNER expr ;
    (23) retourner -> . retourner
    (21) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (17) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (16) affectation -> . IDENTIFIANT = expr ;
    (15) declaration -> . type IDENTIFIANT = expr ;
    (14) ecrire -> . ECRIRE ( expr ) ;
    (45) type -> . ENT
    (46) type -> . BOOLEEN
    }               shift and go to state 102
    IDENTIFIANT     shift and go to state 15
    RETOURNER       shift and go to state 16
    TANTQUE         shift and go to state 17
    SI              shift and go to state 18
    ECRIRE          shift and go to state 19
    ENT             shift and go to state 20
    BOOLEEN         shift and go to state 21

    instruction                    shift and go to state 22
    fonction_declaration           shift and go to state 5
    appel_fonction_1               shift and go to state 6
    appel_fonction_2               shift and go to state 7
    retourner                      shift and go to state 8
    boucle                         shift and go to state 9
    condition                      shift and go to state 10
    affectation                    shift and go to state 11
    declaration                    shift and go to state 12
    ecrire                         shift and go to state 13
    type                           shift and go to state 14

state 102

    (19) suite_sinosi -> SINON SI ( expr ) { listeInstructions } . suite_sinosi
    (18) suite_sinosi -> .
    (19) suite_sinosi -> . SINON SI ( expr ) { listeInstructions } suite_sinosi
    (20) suite_sinosi -> . SINON { listeInstructions }
    IDENTIFIANT     reduce using rule 18 (suite_sinosi -> .)
    RETOURNER       reduce using rule 18 (suite_sinosi -> .)
    TANTQUE         reduce using rule 18 (suite_sinosi -> .)
    SI              reduce using rule 18 (suite_sinosi -> .)
    ECRIRE          reduce using rule 18 (suite_sinosi -> .)
    ENT             reduce using rule 18 (suite_sinosi -> .)
    BOOLEEN         reduce using rule 18 (suite_sinosi -> .)
    $end            reduce using rule 18 (suite_sinosi -> .)
    }               reduce using rule 18 (suite_sinosi -> .)
    SINON           shift and go to state 92

    suite_sinosi                   shift and go to state 103

state 103

    (19) suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .
    IDENTIFIANT     reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    RETOURNER       reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    TANTQUE         reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    SI              reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    ECRIRE          reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    ENT             reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    BOOLEEN         reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    $end            reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    }               reduce using rule 19 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)


Conflicts:

shift/reduce conflict for MODULO in state 27 resolved as shift
shift/reduce conflict for DIV in state 27 resolved as shift
shift/reduce conflict for MULT in state 27 resolved as shift
shift/reduce conflict for OU in state 29 resolved as shift
shift/reduce conflict for ET in state 29 resolved as shift
reduce/reduce conflict in state 8 resolved using rule instruction -> retourner
rejected rule (retourner -> retourner) in state 8
Rule (retourner -> retourner) is never reduced