Grammar:

Rule 0     S' -> statement
Rule 1     statement -> prog
Rule 2     prog -> listeInstructions
Rule 3     listeInstructions -> listeInstructions instruction
Rule 4     listeInstructions -> instruction
Rule 5     instruction -> boucle
Rule 6     instruction -> structure_conditionnelle
Rule 7     instruction -> affectation
Rule 8     instruction -> declaration
Rule 9     instruction -> ecrire
Rule 10    ecrire -> ECRIRE ( expr ) ;
Rule 11    declaration -> BOOLEEN IDENTIFIANT = expr ;
Rule 12    declaration -> ENT IDENTIFIANT = expr ;
Rule 13    affectation -> IDENTIFIANT = expr ;
Rule 14    structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions }
Rule 15    boucle -> TANTQUE expr { listeInstructions }
Rule 16    expr -> NON IDENTIFIANT
Rule 17    expr -> NON BOOLEEN_LITERAL
Rule 18    expr -> term
Rule 19    expr -> expr DIFF expr  [precedence=nonassoc, level=1]
Rule 20    expr -> expr EGAL expr  [precedence=nonassoc, level=1]
Rule 21    expr -> expr COMPARATEUR expr  [precedence=nonassoc, level=1]
Rule 22    expr -> expr SUP expr  [precedence=nonassoc, level=1]
Rule 23    expr -> expr INF expr  [precedence=nonassoc, level=1]
Rule 24    expr -> expr OU expr  [precedence=left, level=6]
Rule 25    expr -> expr ET expr  [precedence=left, level=5]
Rule 26    expr -> expr MINUS term  [precedence=left, level=2]
Rule 27    expr -> expr PLUS term  [precedence=left, level=2]
Rule 28    term -> factor
Rule 29    term -> term DIV factor  [precedence=left, level=3]
Rule 30    term -> term MULT factor  [precedence=left, level=3]
Rule 31    factor -> BOOLEEN_LITERAL
Rule 32    factor -> BOOLEEN
Rule 33    factor -> ( expr )
Rule 34    factor -> IDENTIFIANT
Rule 35    factor -> ENTIER

Unused terminals:

    INF_EGAL
    UMINUS
    SUP_EGAL

Terminals, with rules where they appear:

(                    : 10 33
)                    : 10 33
;                    : 10 11 12 13
=                    : 11 12 13
ALORS                : 14
BOOLEEN              : 11 32
BOOLEEN_LITERAL      : 17 31
COMPARATEUR          : 21
DIFF                 : 19
DIV                  : 29
ECRIRE               : 10
EGAL                 : 20
ENT                  : 12
ENTIER               : 35
ET                   : 25
IDENTIFIANT          : 11 12 13 16 34
INF                  : 23
INF_EGAL             : 
MINUS                : 26
MULT                 : 30
NON                  : 16 17
OU                   : 24
PLUS                 : 27
SI                   : 14
SINON                : 14
SUP                  : 22
SUP_EGAL             : 
TANTQUE              : 15
UMINUS               : 
error                : 
{                    : 14 14 15
}                    : 14 14 15

Nonterminals, with rules where they appear:

affectation          : 7
boucle               : 5
declaration          : 8
ecrire               : 9
expr                 : 10 11 12 13 14 15 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 27 33
factor               : 28 29 30
instruction          : 3 4
listeInstructions    : 2 3 14 14 15
prog                 : 1
statement            : 0
structure_conditionnelle : 6
term                 : 18 26 27 29 30


state 0

    (0) S' -> . statement
    (1) statement -> . prog
    (2) prog -> . listeInstructions
    (3) listeInstructions -> . listeInstructions instruction
    (4) listeInstructions -> . instruction
    (5) instruction -> . boucle
    (6) instruction -> . structure_conditionnelle
    (7) instruction -> . affectation
    (8) instruction -> . declaration
    (9) instruction -> . ecrire
    (15) boucle -> . TANTQUE expr { listeInstructions }
    (14) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (13) affectation -> . IDENTIFIANT = expr ;
    (11) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (12) declaration -> . ENT IDENTIFIANT = expr ;
    (10) ecrire -> . ECRIRE ( expr ) ;
    TANTQUE         shift and go to state 10
    SI              shift and go to state 11
    IDENTIFIANT     shift and go to state 12
    BOOLEEN         shift and go to state 13
    ENT             shift and go to state 14
    ECRIRE          shift and go to state 15

    statement                      shift and go to state 1
    prog                           shift and go to state 2
    listeInstructions              shift and go to state 3
    instruction                    shift and go to state 4
    boucle                         shift and go to state 5
    structure_conditionnelle       shift and go to state 6
    affectation                    shift and go to state 7
    declaration                    shift and go to state 8
    ecrire                         shift and go to state 9

state 1

    (0) S' -> statement .


state 2

    (1) statement -> prog .
    $end            reduce using rule 1 (statement -> prog .)


state 3

    (2) prog -> listeInstructions .
    (3) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . boucle
    (6) instruction -> . structure_conditionnelle
    (7) instruction -> . affectation
    (8) instruction -> . declaration
    (9) instruction -> . ecrire
    (15) boucle -> . TANTQUE expr { listeInstructions }
    (14) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (13) affectation -> . IDENTIFIANT = expr ;
    (11) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (12) declaration -> . ENT IDENTIFIANT = expr ;
    (10) ecrire -> . ECRIRE ( expr ) ;
    $end            reduce using rule 2 (prog -> listeInstructions .)
    TANTQUE         shift and go to state 10
    SI              shift and go to state 11
    IDENTIFIANT     shift and go to state 12
    BOOLEEN         shift and go to state 13
    ENT             shift and go to state 14
    ECRIRE          shift and go to state 15

    instruction                    shift and go to state 16
    boucle                         shift and go to state 5
    structure_conditionnelle       shift and go to state 6
    affectation                    shift and go to state 7
    declaration                    shift and go to state 8
    ecrire                         shift and go to state 9

state 4

    (4) listeInstructions -> instruction .
    TANTQUE         reduce using rule 4 (listeInstructions -> instruction .)
    SI              reduce using rule 4 (listeInstructions -> instruction .)
    IDENTIFIANT     reduce using rule 4 (listeInstructions -> instruction .)
    BOOLEEN         reduce using rule 4 (listeInstructions -> instruction .)
    ENT             reduce using rule 4 (listeInstructions -> instruction .)
    ECRIRE          reduce using rule 4 (listeInstructions -> instruction .)
    $end            reduce using rule 4 (listeInstructions -> instruction .)
    }               reduce using rule 4 (listeInstructions -> instruction .)


state 5

    (5) instruction -> boucle .
    TANTQUE         reduce using rule 5 (instruction -> boucle .)
    SI              reduce using rule 5 (instruction -> boucle .)
    IDENTIFIANT     reduce using rule 5 (instruction -> boucle .)
    BOOLEEN         reduce using rule 5 (instruction -> boucle .)
    ENT             reduce using rule 5 (instruction -> boucle .)
    ECRIRE          reduce using rule 5 (instruction -> boucle .)
    $end            reduce using rule 5 (instruction -> boucle .)
    }               reduce using rule 5 (instruction -> boucle .)


state 6

    (6) instruction -> structure_conditionnelle .
    TANTQUE         reduce using rule 6 (instruction -> structure_conditionnelle .)
    SI              reduce using rule 6 (instruction -> structure_conditionnelle .)
    IDENTIFIANT     reduce using rule 6 (instruction -> structure_conditionnelle .)
    BOOLEEN         reduce using rule 6 (instruction -> structure_conditionnelle .)
    ENT             reduce using rule 6 (instruction -> structure_conditionnelle .)
    ECRIRE          reduce using rule 6 (instruction -> structure_conditionnelle .)
    $end            reduce using rule 6 (instruction -> structure_conditionnelle .)
    }               reduce using rule 6 (instruction -> structure_conditionnelle .)


state 7

    (7) instruction -> affectation .
    TANTQUE         reduce using rule 7 (instruction -> affectation .)
    SI              reduce using rule 7 (instruction -> affectation .)
    IDENTIFIANT     reduce using rule 7 (instruction -> affectation .)
    BOOLEEN         reduce using rule 7 (instruction -> affectation .)
    ENT             reduce using rule 7 (instruction -> affectation .)
    ECRIRE          reduce using rule 7 (instruction -> affectation .)
    $end            reduce using rule 7 (instruction -> affectation .)
    }               reduce using rule 7 (instruction -> affectation .)


state 8

    (8) instruction -> declaration .
    TANTQUE         reduce using rule 8 (instruction -> declaration .)
    SI              reduce using rule 8 (instruction -> declaration .)
    IDENTIFIANT     reduce using rule 8 (instruction -> declaration .)
    BOOLEEN         reduce using rule 8 (instruction -> declaration .)
    ENT             reduce using rule 8 (instruction -> declaration .)
    ECRIRE          reduce using rule 8 (instruction -> declaration .)
    $end            reduce using rule 8 (instruction -> declaration .)
    }               reduce using rule 8 (instruction -> declaration .)


state 9

    (9) instruction -> ecrire .
    TANTQUE         reduce using rule 9 (instruction -> ecrire .)
    SI              reduce using rule 9 (instruction -> ecrire .)
    IDENTIFIANT     reduce using rule 9 (instruction -> ecrire .)
    BOOLEEN         reduce using rule 9 (instruction -> ecrire .)
    ENT             reduce using rule 9 (instruction -> ecrire .)
    ECRIRE          reduce using rule 9 (instruction -> ecrire .)
    $end            reduce using rule 9 (instruction -> ecrire .)
    }               reduce using rule 9 (instruction -> ecrire .)


state 10

    (14) structure_conditionnelle -> SI . expr ALORS { listeInstructions } SINON { listeInstructions }
    (15) expr -> . NON expr
    (16) expr -> . term
    (17) expr -> . expr OU expr
    (18) expr -> . expr ET expr
    (19) expr -> . expr MINUS term
    (20) expr -> . expr PLUS term
    (21) term -> . factor
    (22) term -> . term DIV factor
    (23) term -> . term MULT factor
    (24) factor -> . ( expr )
    (25) factor -> . IDENTIFIANT
    (26) factor -> . ENTIER
    NON             shift and go to state 17
    (               shift and go to state 20
    IDENTIFIANT     shift and go to state 21
    ENTIER          shift and go to state 22

    expr                           shift and go to state 17
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 11

    (14) structure_conditionnelle -> SI . expr ALORS { listeInstructions } SINON { listeInstructions }
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 26
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 12

    (13) affectation -> IDENTIFIANT . = expr ;
    =               shift and go to state 27


state 13

    (11) declaration -> BOOLEEN . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 28


state 14

    (12) declaration -> ENT . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 29


state 15

    (10) ecrire -> ECRIRE . ( expr ) ;
    (               shift and go to state 30


state 16

    (3) listeInstructions -> listeInstructions instruction .
    TANTQUE         reduce using rule 3 (listeInstructions -> listeInstructions instruction .)
    SI              reduce using rule 3 (listeInstructions -> listeInstructions instruction .)
    IDENTIFIANT     reduce using rule 3 (listeInstructions -> listeInstructions instruction .)
    BOOLEEN         reduce using rule 3 (listeInstructions -> listeInstructions instruction .)
    ENT             reduce using rule 3 (listeInstructions -> listeInstructions instruction .)
    ECRIRE          reduce using rule 3 (listeInstructions -> listeInstructions instruction .)
    $end            reduce using rule 3 (listeInstructions -> listeInstructions instruction .)
    }               reduce using rule 3 (listeInstructions -> listeInstructions instruction .)


state 17

    (15) boucle -> TANTQUE expr . { listeInstructions }
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    {               shift and go to state 31
    DIFF            shift and go to state 32
    EGAL            shift and go to state 33
    COMPARATEUR     shift and go to state 34
    SUP             shift and go to state 35
    INF             shift and go to state 36
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 18

    (16) expr -> NON . IDENTIFIANT
    (17) expr -> NON . BOOLEEN_LITERAL
    IDENTIFIANT     shift and go to state 41
    BOOLEEN_LITERAL shift and go to state 42


state 19

    (34) factor -> IDENTIFIANT .
    DIV             reduce using rule 34 (factor -> IDENTIFIANT .)
    MULT            reduce using rule 34 (factor -> IDENTIFIANT .)
    {               reduce using rule 34 (factor -> IDENTIFIANT .)
    DIFF            reduce using rule 34 (factor -> IDENTIFIANT .)
    EGAL            reduce using rule 34 (factor -> IDENTIFIANT .)
    COMPARATEUR     reduce using rule 34 (factor -> IDENTIFIANT .)
    SUP             reduce using rule 34 (factor -> IDENTIFIANT .)
    INF             reduce using rule 34 (factor -> IDENTIFIANT .)
    OU              reduce using rule 34 (factor -> IDENTIFIANT .)
    ET              reduce using rule 34 (factor -> IDENTIFIANT .)
    MINUS           reduce using rule 34 (factor -> IDENTIFIANT .)
    PLUS            reduce using rule 34 (factor -> IDENTIFIANT .)
    ALORS           reduce using rule 34 (factor -> IDENTIFIANT .)
    )               reduce using rule 34 (factor -> IDENTIFIANT .)
    ;               reduce using rule 34 (factor -> IDENTIFIANT .)


state 20

    (31) factor -> BOOLEEN_LITERAL .
    DIV             reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    MULT            reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    {               reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    DIFF            reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    EGAL            reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    COMPARATEUR     reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    SUP             reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    INF             reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    OU              reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    ET              reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    MINUS           reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    PLUS            reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    ALORS           reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    )               reduce using rule 31 (factor -> BOOLEEN_LITERAL .)
    ;               reduce using rule 31 (factor -> BOOLEEN_LITERAL .)


state 21

    (18) expr -> term .
    (29) term -> term . DIV factor
    (30) term -> term . MULT factor
    {               reduce using rule 18 (expr -> term .)
    DIFF            reduce using rule 18 (expr -> term .)
    EGAL            reduce using rule 18 (expr -> term .)
    COMPARATEUR     reduce using rule 18 (expr -> term .)
    SUP             reduce using rule 18 (expr -> term .)
    INF             reduce using rule 18 (expr -> term .)
    OU              reduce using rule 18 (expr -> term .)
    ET              reduce using rule 18 (expr -> term .)
    MINUS           reduce using rule 18 (expr -> term .)
    PLUS            reduce using rule 18 (expr -> term .)
    ALORS           reduce using rule 18 (expr -> term .)
    )               reduce using rule 18 (expr -> term .)
    ;               reduce using rule 18 (expr -> term .)
    DIV             shift and go to state 43
    MULT            shift and go to state 44


state 22

    (28) term -> factor .
    DIV             reduce using rule 28 (term -> factor .)
    MULT            reduce using rule 28 (term -> factor .)
    {               reduce using rule 28 (term -> factor .)
    DIFF            reduce using rule 28 (term -> factor .)
    EGAL            reduce using rule 28 (term -> factor .)
    COMPARATEUR     reduce using rule 28 (term -> factor .)
    SUP             reduce using rule 28 (term -> factor .)
    INF             reduce using rule 28 (term -> factor .)
    OU              reduce using rule 28 (term -> factor .)
    ET              reduce using rule 28 (term -> factor .)
    MINUS           reduce using rule 28 (term -> factor .)
    PLUS            reduce using rule 28 (term -> factor .)
    ALORS           reduce using rule 28 (term -> factor .)
    )               reduce using rule 28 (term -> factor .)
    ;               reduce using rule 28 (term -> factor .)


state 23

    (32) factor -> BOOLEEN .
    DIV             reduce using rule 32 (factor -> BOOLEEN .)
    MULT            reduce using rule 32 (factor -> BOOLEEN .)
    {               reduce using rule 32 (factor -> BOOLEEN .)
    DIFF            reduce using rule 32 (factor -> BOOLEEN .)
    EGAL            reduce using rule 32 (factor -> BOOLEEN .)
    COMPARATEUR     reduce using rule 32 (factor -> BOOLEEN .)
    SUP             reduce using rule 32 (factor -> BOOLEEN .)
    INF             reduce using rule 32 (factor -> BOOLEEN .)
    OU              reduce using rule 32 (factor -> BOOLEEN .)
    ET              reduce using rule 32 (factor -> BOOLEEN .)
    MINUS           reduce using rule 32 (factor -> BOOLEEN .)
    PLUS            reduce using rule 32 (factor -> BOOLEEN .)
    ALORS           reduce using rule 32 (factor -> BOOLEEN .)
    )               reduce using rule 32 (factor -> BOOLEEN .)
    ;               reduce using rule 32 (factor -> BOOLEEN .)


state 24

    (33) factor -> ( . expr )
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 45
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 25

    (35) factor -> ENTIER .
    DIV             reduce using rule 35 (factor -> ENTIER .)
    MULT            reduce using rule 35 (factor -> ENTIER .)
    {               reduce using rule 35 (factor -> ENTIER .)
    DIFF            reduce using rule 35 (factor -> ENTIER .)
    EGAL            reduce using rule 35 (factor -> ENTIER .)
    COMPARATEUR     reduce using rule 35 (factor -> ENTIER .)
    SUP             reduce using rule 35 (factor -> ENTIER .)
    INF             reduce using rule 35 (factor -> ENTIER .)
    OU              reduce using rule 35 (factor -> ENTIER .)
    ET              reduce using rule 35 (factor -> ENTIER .)
    MINUS           reduce using rule 35 (factor -> ENTIER .)
    PLUS            reduce using rule 35 (factor -> ENTIER .)
    ALORS           reduce using rule 35 (factor -> ENTIER .)
    )               reduce using rule 35 (factor -> ENTIER .)
    ;               reduce using rule 35 (factor -> ENTIER .)


state 26

    (14) structure_conditionnelle -> SI expr . ALORS { listeInstructions } SINON { listeInstructions }
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    ALORS           shift and go to state 46
    DIFF            shift and go to state 32
    EGAL            shift and go to state 33
    COMPARATEUR     shift and go to state 34
    SUP             shift and go to state 35
    INF             shift and go to state 36
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 27

    (13) affectation -> IDENTIFIANT = . expr ;
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 47
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 28

    (11) declaration -> BOOLEEN IDENTIFIANT . = expr ;
    =               shift and go to state 48


state 29

    (12) declaration -> ENT IDENTIFIANT . = expr ;
    =               shift and go to state 49


state 30

    (10) ecrire -> ECRIRE ( . expr ) ;
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 50
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 31

    (15) boucle -> TANTQUE expr { . listeInstructions }
    (3) listeInstructions -> . listeInstructions instruction
    (4) listeInstructions -> . instruction
    (5) instruction -> . boucle
    (6) instruction -> . structure_conditionnelle
    (7) instruction -> . affectation
    (8) instruction -> . declaration
    (9) instruction -> . ecrire
    (15) boucle -> . TANTQUE expr { listeInstructions }
    (14) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (13) affectation -> . IDENTIFIANT = expr ;
    (11) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (12) declaration -> . ENT IDENTIFIANT = expr ;
    (10) ecrire -> . ECRIRE ( expr ) ;
    TANTQUE         shift and go to state 10
    SI              shift and go to state 11
    IDENTIFIANT     shift and go to state 12
    BOOLEEN         shift and go to state 13
    ENT             shift and go to state 14
    ECRIRE          shift and go to state 15

    listeInstructions              shift and go to state 51
    instruction                    shift and go to state 4
    boucle                         shift and go to state 5
    structure_conditionnelle       shift and go to state 6
    affectation                    shift and go to state 7
    declaration                    shift and go to state 8
    ecrire                         shift and go to state 9

state 32

    (19) expr -> expr DIFF . expr
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 52
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 33

    (20) expr -> expr EGAL . expr
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 53
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 34

    (21) expr -> expr COMPARATEUR . expr
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 54
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 35

    (22) expr -> expr SUP . expr
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 55
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 36

    (23) expr -> expr INF . expr
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 56
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 37

    (24) expr -> expr OU . expr
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 57
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 38

    (25) expr -> expr ET . expr
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 58
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 39

    (26) expr -> expr MINUS . term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    term                           shift and go to state 59
    factor                         shift and go to state 22

state 40

    (27) expr -> expr PLUS . term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    term                           shift and go to state 60
    factor                         shift and go to state 22

state 41

    (16) expr -> NON IDENTIFIANT .
    {               reduce using rule 16 (expr -> NON IDENTIFIANT .)
    DIFF            reduce using rule 16 (expr -> NON IDENTIFIANT .)
    EGAL            reduce using rule 16 (expr -> NON IDENTIFIANT .)
    COMPARATEUR     reduce using rule 16 (expr -> NON IDENTIFIANT .)
    SUP             reduce using rule 16 (expr -> NON IDENTIFIANT .)
    INF             reduce using rule 16 (expr -> NON IDENTIFIANT .)
    OU              reduce using rule 16 (expr -> NON IDENTIFIANT .)
    ET              reduce using rule 16 (expr -> NON IDENTIFIANT .)
    MINUS           reduce using rule 16 (expr -> NON IDENTIFIANT .)
    PLUS            reduce using rule 16 (expr -> NON IDENTIFIANT .)
    ALORS           reduce using rule 16 (expr -> NON IDENTIFIANT .)
    )               reduce using rule 16 (expr -> NON IDENTIFIANT .)
    ;               reduce using rule 16 (expr -> NON IDENTIFIANT .)


state 42

    (17) expr -> NON BOOLEEN_LITERAL .
    {               reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    DIFF            reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    EGAL            reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    COMPARATEUR     reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    SUP             reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    INF             reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    OU              reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    ET              reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    MINUS           reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    PLUS            reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    ALORS           reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    )               reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)
    ;               reduce using rule 17 (expr -> NON BOOLEEN_LITERAL .)


state 43

    (29) term -> term DIV . factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    factor                         shift and go to state 61

state 44

    (30) term -> term MULT . factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    factor                         shift and go to state 62

state 45

    (33) factor -> ( expr . )
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    )               shift and go to state 63
    DIFF            shift and go to state 32
    EGAL            shift and go to state 33
    COMPARATEUR     shift and go to state 34
    SUP             shift and go to state 35
    INF             shift and go to state 36
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 46

    (14) structure_conditionnelle -> SI expr ALORS . { listeInstructions } SINON { listeInstructions }
    {               shift and go to state 64


state 47

    (13) affectation -> IDENTIFIANT = expr . ;
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    ;               shift and go to state 65
    DIFF            shift and go to state 32
    EGAL            shift and go to state 33
    COMPARATEUR     shift and go to state 34
    SUP             shift and go to state 35
    INF             shift and go to state 36
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 48

    (11) declaration -> BOOLEEN IDENTIFIANT = . expr ;
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 66
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 49

    (12) declaration -> ENT IDENTIFIANT = . expr ;
    (16) expr -> . NON IDENTIFIANT
    (17) expr -> . NON BOOLEEN_LITERAL
    (18) expr -> . term
    (19) expr -> . expr DIFF expr
    (20) expr -> . expr EGAL expr
    (21) expr -> . expr COMPARATEUR expr
    (22) expr -> . expr SUP expr
    (23) expr -> . expr INF expr
    (24) expr -> . expr OU expr
    (25) expr -> . expr ET expr
    (26) expr -> . expr MINUS term
    (27) expr -> . expr PLUS term
    (28) term -> . factor
    (29) term -> . term DIV factor
    (30) term -> . term MULT factor
    (31) factor -> . BOOLEEN_LITERAL
    (32) factor -> . BOOLEEN
    (33) factor -> . ( expr )
    (34) factor -> . IDENTIFIANT
    (35) factor -> . ENTIER
    NON             shift and go to state 18
    BOOLEEN_LITERAL shift and go to state 20
    BOOLEEN         shift and go to state 23
    (               shift and go to state 24
    IDENTIFIANT     shift and go to state 19
    ENTIER          shift and go to state 25

    expr                           shift and go to state 67
    term                           shift and go to state 21
    factor                         shift and go to state 22

state 50

    (10) ecrire -> ECRIRE ( expr . ) ;
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    )               shift and go to state 68
    DIFF            shift and go to state 32
    EGAL            shift and go to state 33
    COMPARATEUR     shift and go to state 34
    SUP             shift and go to state 35
    INF             shift and go to state 36
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 51

    (15) boucle -> TANTQUE expr { listeInstructions . }
    (3) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . boucle
    (6) instruction -> . structure_conditionnelle
    (7) instruction -> . affectation
    (8) instruction -> . declaration
    (9) instruction -> . ecrire
    (15) boucle -> . TANTQUE expr { listeInstructions }
    (14) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (13) affectation -> . IDENTIFIANT = expr ;
    (11) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (12) declaration -> . ENT IDENTIFIANT = expr ;
    (10) ecrire -> . ECRIRE ( expr ) ;
    }               shift and go to state 69
    TANTQUE         shift and go to state 10
    SI              shift and go to state 11
    IDENTIFIANT     shift and go to state 12
    BOOLEEN         shift and go to state 13
    ENT             shift and go to state 14
    ECRIRE          shift and go to state 15

    instruction                    shift and go to state 16
    boucle                         shift and go to state 5
    structure_conditionnelle       shift and go to state 6
    affectation                    shift and go to state 7
    declaration                    shift and go to state 8
    ecrire                         shift and go to state 9

state 52

    (19) expr -> expr DIFF expr .
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    {               reduce using rule 19 (expr -> expr DIFF expr .)
    DIFF            reduce using rule 19 (expr -> expr DIFF expr .)
    EGAL            reduce using rule 19 (expr -> expr DIFF expr .)
    COMPARATEUR     reduce using rule 19 (expr -> expr DIFF expr .)
    SUP             reduce using rule 19 (expr -> expr DIFF expr .)
    INF             reduce using rule 19 (expr -> expr DIFF expr .)
    ALORS           reduce using rule 19 (expr -> expr DIFF expr .)
    )               reduce using rule 19 (expr -> expr DIFF expr .)
    ;               reduce using rule 19 (expr -> expr DIFF expr .)
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 53

    (20) expr -> expr EGAL expr .
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    {               reduce using rule 20 (expr -> expr EGAL expr .)
    DIFF            reduce using rule 20 (expr -> expr EGAL expr .)
    EGAL            reduce using rule 20 (expr -> expr EGAL expr .)
    COMPARATEUR     reduce using rule 20 (expr -> expr EGAL expr .)
    SUP             reduce using rule 20 (expr -> expr EGAL expr .)
    INF             reduce using rule 20 (expr -> expr EGAL expr .)
    ALORS           reduce using rule 20 (expr -> expr EGAL expr .)
    )               reduce using rule 20 (expr -> expr EGAL expr .)
    ;               reduce using rule 20 (expr -> expr EGAL expr .)
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 54

    (21) expr -> expr COMPARATEUR expr .
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    {               reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    DIFF            reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    EGAL            reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    COMPARATEUR     reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    SUP             reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    INF             reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    ALORS           reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    )               reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    ;               reduce using rule 21 (expr -> expr COMPARATEUR expr .)
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 55

    (22) expr -> expr SUP expr .
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    {               reduce using rule 22 (expr -> expr SUP expr .)
    DIFF            reduce using rule 22 (expr -> expr SUP expr .)
    EGAL            reduce using rule 22 (expr -> expr SUP expr .)
    COMPARATEUR     reduce using rule 22 (expr -> expr SUP expr .)
    SUP             reduce using rule 22 (expr -> expr SUP expr .)
    INF             reduce using rule 22 (expr -> expr SUP expr .)
    ALORS           reduce using rule 22 (expr -> expr SUP expr .)
    )               reduce using rule 22 (expr -> expr SUP expr .)
    ;               reduce using rule 22 (expr -> expr SUP expr .)
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 56

    (23) expr -> expr INF expr .
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    {               reduce using rule 23 (expr -> expr INF expr .)
    DIFF            reduce using rule 23 (expr -> expr INF expr .)
    EGAL            reduce using rule 23 (expr -> expr INF expr .)
    COMPARATEUR     reduce using rule 23 (expr -> expr INF expr .)
    SUP             reduce using rule 23 (expr -> expr INF expr .)
    INF             reduce using rule 23 (expr -> expr INF expr .)
    ALORS           reduce using rule 23 (expr -> expr INF expr .)
    )               reduce using rule 23 (expr -> expr INF expr .)
    ;               reduce using rule 23 (expr -> expr INF expr .)
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 57

    (24) expr -> expr OU expr .
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    {               reduce using rule 24 (expr -> expr OU expr .)
    DIFF            reduce using rule 24 (expr -> expr OU expr .)
    EGAL            reduce using rule 24 (expr -> expr OU expr .)
    COMPARATEUR     reduce using rule 24 (expr -> expr OU expr .)
    SUP             reduce using rule 24 (expr -> expr OU expr .)
    INF             reduce using rule 24 (expr -> expr OU expr .)
    OU              reduce using rule 24 (expr -> expr OU expr .)
    ET              reduce using rule 24 (expr -> expr OU expr .)
    MINUS           reduce using rule 24 (expr -> expr OU expr .)
    PLUS            reduce using rule 24 (expr -> expr OU expr .)
    ALORS           reduce using rule 24 (expr -> expr OU expr .)
    )               reduce using rule 24 (expr -> expr OU expr .)
    ;               reduce using rule 24 (expr -> expr OU expr .)


state 58

    (25) expr -> expr ET expr .
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    {               reduce using rule 25 (expr -> expr ET expr .)
    DIFF            reduce using rule 25 (expr -> expr ET expr .)
    EGAL            reduce using rule 25 (expr -> expr ET expr .)
    COMPARATEUR     reduce using rule 25 (expr -> expr ET expr .)
    SUP             reduce using rule 25 (expr -> expr ET expr .)
    INF             reduce using rule 25 (expr -> expr ET expr .)
    ET              reduce using rule 25 (expr -> expr ET expr .)
    MINUS           reduce using rule 25 (expr -> expr ET expr .)
    PLUS            reduce using rule 25 (expr -> expr ET expr .)
    ALORS           reduce using rule 25 (expr -> expr ET expr .)
    )               reduce using rule 25 (expr -> expr ET expr .)
    ;               reduce using rule 25 (expr -> expr ET expr .)
    OU              shift and go to state 37


state 59

    (26) expr -> expr MINUS term .
    (29) term -> term . DIV factor
    (30) term -> term . MULT factor
    {               reduce using rule 26 (expr -> expr MINUS term .)
    DIFF            reduce using rule 26 (expr -> expr MINUS term .)
    EGAL            reduce using rule 26 (expr -> expr MINUS term .)
    COMPARATEUR     reduce using rule 26 (expr -> expr MINUS term .)
    SUP             reduce using rule 26 (expr -> expr MINUS term .)
    INF             reduce using rule 26 (expr -> expr MINUS term .)
    OU              reduce using rule 26 (expr -> expr MINUS term .)
    ET              reduce using rule 26 (expr -> expr MINUS term .)
    MINUS           reduce using rule 26 (expr -> expr MINUS term .)
    PLUS            reduce using rule 26 (expr -> expr MINUS term .)
    ALORS           reduce using rule 26 (expr -> expr MINUS term .)
    )               reduce using rule 26 (expr -> expr MINUS term .)
    ;               reduce using rule 26 (expr -> expr MINUS term .)
    DIV             shift and go to state 43
    MULT            shift and go to state 44


state 60

    (27) expr -> expr PLUS term .
    (29) term -> term . DIV factor
    (30) term -> term . MULT factor
    {               reduce using rule 27 (expr -> expr PLUS term .)
    DIFF            reduce using rule 27 (expr -> expr PLUS term .)
    EGAL            reduce using rule 27 (expr -> expr PLUS term .)
    COMPARATEUR     reduce using rule 27 (expr -> expr PLUS term .)
    SUP             reduce using rule 27 (expr -> expr PLUS term .)
    INF             reduce using rule 27 (expr -> expr PLUS term .)
    OU              reduce using rule 27 (expr -> expr PLUS term .)
    ET              reduce using rule 27 (expr -> expr PLUS term .)
    MINUS           reduce using rule 27 (expr -> expr PLUS term .)
    PLUS            reduce using rule 27 (expr -> expr PLUS term .)
    ALORS           reduce using rule 27 (expr -> expr PLUS term .)
    )               reduce using rule 27 (expr -> expr PLUS term .)
    ;               reduce using rule 27 (expr -> expr PLUS term .)
    DIV             shift and go to state 43
    MULT            shift and go to state 44


state 61

    (29) term -> term DIV factor .
    DIV             reduce using rule 29 (term -> term DIV factor .)
    MULT            reduce using rule 29 (term -> term DIV factor .)
    {               reduce using rule 29 (term -> term DIV factor .)
    DIFF            reduce using rule 29 (term -> term DIV factor .)
    EGAL            reduce using rule 29 (term -> term DIV factor .)
    COMPARATEUR     reduce using rule 29 (term -> term DIV factor .)
    SUP             reduce using rule 29 (term -> term DIV factor .)
    INF             reduce using rule 29 (term -> term DIV factor .)
    OU              reduce using rule 29 (term -> term DIV factor .)
    ET              reduce using rule 29 (term -> term DIV factor .)
    MINUS           reduce using rule 29 (term -> term DIV factor .)
    PLUS            reduce using rule 29 (term -> term DIV factor .)
    ALORS           reduce using rule 29 (term -> term DIV factor .)
    )               reduce using rule 29 (term -> term DIV factor .)
    ;               reduce using rule 29 (term -> term DIV factor .)


state 62

    (30) term -> term MULT factor .
    DIV             reduce using rule 30 (term -> term MULT factor .)
    MULT            reduce using rule 30 (term -> term MULT factor .)
    {               reduce using rule 30 (term -> term MULT factor .)
    DIFF            reduce using rule 30 (term -> term MULT factor .)
    EGAL            reduce using rule 30 (term -> term MULT factor .)
    COMPARATEUR     reduce using rule 30 (term -> term MULT factor .)
    SUP             reduce using rule 30 (term -> term MULT factor .)
    INF             reduce using rule 30 (term -> term MULT factor .)
    OU              reduce using rule 30 (term -> term MULT factor .)
    ET              reduce using rule 30 (term -> term MULT factor .)
    MINUS           reduce using rule 30 (term -> term MULT factor .)
    PLUS            reduce using rule 30 (term -> term MULT factor .)
    ALORS           reduce using rule 30 (term -> term MULT factor .)
    )               reduce using rule 30 (term -> term MULT factor .)
    ;               reduce using rule 30 (term -> term MULT factor .)


state 63

    (33) factor -> ( expr ) .
    DIV             reduce using rule 33 (factor -> ( expr ) .)
    MULT            reduce using rule 33 (factor -> ( expr ) .)
    {               reduce using rule 33 (factor -> ( expr ) .)
    DIFF            reduce using rule 33 (factor -> ( expr ) .)
    EGAL            reduce using rule 33 (factor -> ( expr ) .)
    COMPARATEUR     reduce using rule 33 (factor -> ( expr ) .)
    SUP             reduce using rule 33 (factor -> ( expr ) .)
    INF             reduce using rule 33 (factor -> ( expr ) .)
    OU              reduce using rule 33 (factor -> ( expr ) .)
    ET              reduce using rule 33 (factor -> ( expr ) .)
    MINUS           reduce using rule 33 (factor -> ( expr ) .)
    PLUS            reduce using rule 33 (factor -> ( expr ) .)
    ALORS           reduce using rule 33 (factor -> ( expr ) .)
    )               reduce using rule 33 (factor -> ( expr ) .)
    ;               reduce using rule 33 (factor -> ( expr ) .)


state 64

    (14) structure_conditionnelle -> SI expr ALORS { . listeInstructions } SINON { listeInstructions }
    (3) listeInstructions -> . listeInstructions instruction
    (4) listeInstructions -> . instruction
    (5) instruction -> . boucle
    (6) instruction -> . structure_conditionnelle
    (7) instruction -> . affectation
    (8) instruction -> . declaration
    (9) instruction -> . ecrire
    (15) boucle -> . TANTQUE expr { listeInstructions }
    (14) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (13) affectation -> . IDENTIFIANT = expr ;
    (11) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (12) declaration -> . ENT IDENTIFIANT = expr ;
    (10) ecrire -> . ECRIRE ( expr ) ;
    TANTQUE         shift and go to state 10
    SI              shift and go to state 11
    IDENTIFIANT     shift and go to state 12
    BOOLEEN         shift and go to state 13
    ENT             shift and go to state 14
    ECRIRE          shift and go to state 15

    listeInstructions              shift and go to state 70
    instruction                    shift and go to state 4
    boucle                         shift and go to state 5
    structure_conditionnelle       shift and go to state 6
    affectation                    shift and go to state 7
    declaration                    shift and go to state 8
    ecrire                         shift and go to state 9

state 65

    (13) affectation -> IDENTIFIANT = expr ; .
    TANTQUE         reduce using rule 13 (affectation -> IDENTIFIANT = expr ; .)
    SI              reduce using rule 13 (affectation -> IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 13 (affectation -> IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 13 (affectation -> IDENTIFIANT = expr ; .)
    ENT             reduce using rule 13 (affectation -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 13 (affectation -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 13 (affectation -> IDENTIFIANT = expr ; .)
    }               reduce using rule 13 (affectation -> IDENTIFIANT = expr ; .)


state 66

    (11) declaration -> BOOLEEN IDENTIFIANT = expr . ;
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    ;               shift and go to state 71
    DIFF            shift and go to state 32
    EGAL            shift and go to state 33
    COMPARATEUR     shift and go to state 34
    SUP             shift and go to state 35
    INF             shift and go to state 36
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 67

    (12) declaration -> ENT IDENTIFIANT = expr . ;
    (19) expr -> expr . DIFF expr
    (20) expr -> expr . EGAL expr
    (21) expr -> expr . COMPARATEUR expr
    (22) expr -> expr . SUP expr
    (23) expr -> expr . INF expr
    (24) expr -> expr . OU expr
    (25) expr -> expr . ET expr
    (26) expr -> expr . MINUS term
    (27) expr -> expr . PLUS term
    ;               shift and go to state 72
    DIFF            shift and go to state 32
    EGAL            shift and go to state 33
    COMPARATEUR     shift and go to state 34
    SUP             shift and go to state 35
    INF             shift and go to state 36
    OU              shift and go to state 37
    ET              shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 68

    (10) ecrire -> ECRIRE ( expr ) . ;
    ;               shift and go to state 73


state 69

    (15) boucle -> TANTQUE expr { listeInstructions } .
    TANTQUE         reduce using rule 15 (boucle -> TANTQUE expr { listeInstructions } .)
    SI              reduce using rule 15 (boucle -> TANTQUE expr { listeInstructions } .)
    IDENTIFIANT     reduce using rule 15 (boucle -> TANTQUE expr { listeInstructions } .)
    BOOLEEN         reduce using rule 15 (boucle -> TANTQUE expr { listeInstructions } .)
    ENT             reduce using rule 15 (boucle -> TANTQUE expr { listeInstructions } .)
    ECRIRE          reduce using rule 15 (boucle -> TANTQUE expr { listeInstructions } .)
    $end            reduce using rule 15 (boucle -> TANTQUE expr { listeInstructions } .)
    }               reduce using rule 15 (boucle -> TANTQUE expr { listeInstructions } .)


state 70

    (14) structure_conditionnelle -> SI expr ALORS { listeInstructions . } SINON { listeInstructions }
    (3) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . boucle
    (6) instruction -> . structure_conditionnelle
    (7) instruction -> . affectation
    (8) instruction -> . declaration
    (9) instruction -> . ecrire
    (15) boucle -> . TANTQUE expr { listeInstructions }
    (14) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (13) affectation -> . IDENTIFIANT = expr ;
    (11) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (12) declaration -> . ENT IDENTIFIANT = expr ;
    (10) ecrire -> . ECRIRE ( expr ) ;
    }               shift and go to state 74
    TANTQUE         shift and go to state 10
    SI              shift and go to state 11
    IDENTIFIANT     shift and go to state 12
    BOOLEEN         shift and go to state 13
    ENT             shift and go to state 14
    ECRIRE          shift and go to state 15

    instruction                    shift and go to state 16
    boucle                         shift and go to state 5
    structure_conditionnelle       shift and go to state 6
    affectation                    shift and go to state 7
    declaration                    shift and go to state 8
    ecrire                         shift and go to state 9

state 71

    (11) declaration -> BOOLEEN IDENTIFIANT = expr ; .
    TANTQUE         reduce using rule 11 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    SI              reduce using rule 11 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 11 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 11 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    ENT             reduce using rule 11 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 11 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    $end            reduce using rule 11 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    }               reduce using rule 11 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)


state 72

    (12) declaration -> ENT IDENTIFIANT = expr ; .
    TANTQUE         reduce using rule 12 (declaration -> ENT IDENTIFIANT = expr ; .)
    SI              reduce using rule 12 (declaration -> ENT IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 12 (declaration -> ENT IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 12 (declaration -> ENT IDENTIFIANT = expr ; .)
    ENT             reduce using rule 12 (declaration -> ENT IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 12 (declaration -> ENT IDENTIFIANT = expr ; .)
    $end            reduce using rule 12 (declaration -> ENT IDENTIFIANT = expr ; .)
    }               reduce using rule 12 (declaration -> ENT IDENTIFIANT = expr ; .)


state 73

    (10) ecrire -> ECRIRE ( expr ) ; .
    TANTQUE         reduce using rule 10 (ecrire -> ECRIRE ( expr ) ; .)
    SI              reduce using rule 10 (ecrire -> ECRIRE ( expr ) ; .)
    IDENTIFIANT     reduce using rule 10 (ecrire -> ECRIRE ( expr ) ; .)
    BOOLEEN         reduce using rule 10 (ecrire -> ECRIRE ( expr ) ; .)
    ENT             reduce using rule 10 (ecrire -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 10 (ecrire -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 10 (ecrire -> ECRIRE ( expr ) ; .)
    }               reduce using rule 10 (ecrire -> ECRIRE ( expr ) ; .)


state 74

    (14) structure_conditionnelle -> SI expr ALORS { listeInstructions } . SINON { listeInstructions }
    SINON           shift and go to state 75


state 75

    (14) structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON . { listeInstructions }
    {               shift and go to state 76


state 76

    (14) structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { . listeInstructions }
    (3) listeInstructions -> . listeInstructions instruction
    (4) listeInstructions -> . instruction
    (5) instruction -> . boucle
    (6) instruction -> . structure_conditionnelle
    (7) instruction -> . affectation
    (8) instruction -> . declaration
    (9) instruction -> . ecrire
    (15) boucle -> . TANTQUE expr { listeInstructions }
    (14) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (13) affectation -> . IDENTIFIANT = expr ;
    (11) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (12) declaration -> . ENT IDENTIFIANT = expr ;
    (10) ecrire -> . ECRIRE ( expr ) ;
    TANTQUE         shift and go to state 10
    SI              shift and go to state 11
    IDENTIFIANT     shift and go to state 12
    BOOLEEN         shift and go to state 13
    ENT             shift and go to state 14
    ECRIRE          shift and go to state 15

    listeInstructions              shift and go to state 77
    instruction                    shift and go to state 4
    boucle                         shift and go to state 5
    structure_conditionnelle       shift and go to state 6
    affectation                    shift and go to state 7
    declaration                    shift and go to state 8
    ecrire                         shift and go to state 9

state 77

    (14) structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions . }
    (3) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . boucle
    (6) instruction -> . structure_conditionnelle
    (7) instruction -> . affectation
    (8) instruction -> . declaration
    (9) instruction -> . ecrire
    (15) boucle -> . TANTQUE expr { listeInstructions }
    (14) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (13) affectation -> . IDENTIFIANT = expr ;
    (11) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (12) declaration -> . ENT IDENTIFIANT = expr ;
    (10) ecrire -> . ECRIRE ( expr ) ;
    }               shift and go to state 78
    TANTQUE         shift and go to state 10
    SI              shift and go to state 11
    IDENTIFIANT     shift and go to state 12
    BOOLEEN         shift and go to state 13
    ENT             shift and go to state 14
    ECRIRE          shift and go to state 15

    instruction                    shift and go to state 16
    boucle                         shift and go to state 5
    structure_conditionnelle       shift and go to state 6
    affectation                    shift and go to state 7
    declaration                    shift and go to state 8
    ecrire                         shift and go to state 9

state 78

    (14) structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .
    TANTQUE         reduce using rule 14 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    SI              reduce using rule 14 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    IDENTIFIANT     reduce using rule 14 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    BOOLEEN         reduce using rule 14 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    ENT             reduce using rule 14 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    ECRIRE          reduce using rule 14 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    $end            reduce using rule 14 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    }               reduce using rule 14 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
