Grammar:

Rule 0     S' -> prog
Rule 1     prog -> listeInstructions
Rule 2     listeInstructions -> instruction listeInstructions
Rule 3     listeInstructions -> instruction
Rule 4     instruction -> structure_conditionnelle
Rule 5     instruction -> affectation
Rule 6     instruction -> declaration
Rule 7     instruction -> ecrire
Rule 8     ecrire -> ECRIRE ( expr ) ;
Rule 9     declaration -> BOOLEEN IDENTIFIANT = expr ;
Rule 10    declaration -> ENT IDENTIFIANT = expr ;
Rule 11    affectation -> IDENTIFIANT = expr ;
Rule 12    structure_conditionnelle -> TANTQUE expr { listeInstructions }
Rule 13    structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions }
Rule 14    expr -> NON expr
Rule 15    expr -> expr INFERIEUR_OU_EGAL expr
Rule 16    expr -> expr > expr
Rule 17    expr -> expr < expr
Rule 18    expr -> expr OU expr
Rule 19    expr -> expr ET expr
Rule 20    expr -> term
Rule 21    expr -> expr MINUS term
Rule 22    expr -> expr PLUS term
Rule 23    term -> factor
Rule 24    term -> term DIV factor
Rule 25    term -> term MULT factor
Rule 26    factor -> ( expr )
Rule 27    factor -> IDENTIFIANT
Rule 28    factor -> ENTIER

Terminals, with rules where they appear:

(                    : 8 26
)                    : 8 26
;                    : 8 9 10 11
<                    : 17
=                    : 9 10 11
>                    : 16
ALORS                : 13
BOOLEEN              : 9
DIV                  : 24
ECRIRE               : 8
ENT                  : 10
ENTIER               : 28
ET                   : 19
IDENTIFIANT          : 9 10 11 27
INFERIEUR_OU_EGAL    : 15
MINUS                : 21
MULT                 : 25
NON                  : 14
OU                   : 18
PLUS                 : 22
SI                   : 13
SINON                : 13
TANTQUE              : 12
error                : 
{                    : 12 13 13
}                    : 12 13 13

Nonterminals, with rules where they appear:

affectation          : 5
declaration          : 6
ecrire               : 7
expr                 : 8 9 10 11 12 13 14 15 15 16 16 17 17 18 18 19 19 21 22 26
factor               : 23 24 25
instruction          : 2 3
listeInstructions    : 1 2 12 13 13
prog                 : 0
structure_conditionnelle : 4
term                 : 20 21 22 24 25


state 0

    (0) S' -> . prog
    (1) prog -> . listeInstructions
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . structure_conditionnelle
    (5) instruction -> . affectation
    (6) instruction -> . declaration
    (7) instruction -> . ecrire
    (12) structure_conditionnelle -> . TANTQUE expr { listeInstructions }
    (13) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (11) affectation -> . IDENTIFIANT = expr ;
    (9) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (10) declaration -> . ENT IDENTIFIANT = expr ;
    (8) ecrire -> . ECRIRE ( expr ) ;
    TANTQUE         shift and go to state 8
    SI              shift and go to state 9
    IDENTIFIANT     shift and go to state 10
    BOOLEEN         shift and go to state 11
    ENT             shift and go to state 12
    ECRIRE          shift and go to state 13

    prog                           shift and go to state 1
    listeInstructions              shift and go to state 2
    instruction                    shift and go to state 3
    structure_conditionnelle       shift and go to state 4
    affectation                    shift and go to state 5
    declaration                    shift and go to state 6
    ecrire                         shift and go to state 7

state 1

    (0) S' -> prog .


state 2

    (1) prog -> listeInstructions .
    $end            reduce using rule 1 (prog -> listeInstructions .)


state 3

    (2) listeInstructions -> instruction . listeInstructions
    (3) listeInstructions -> instruction .
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . structure_conditionnelle
    (5) instruction -> . affectation
    (6) instruction -> . declaration
    (7) instruction -> . ecrire
    (12) structure_conditionnelle -> . TANTQUE expr { listeInstructions }
    (13) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (11) affectation -> . IDENTIFIANT = expr ;
    (9) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (10) declaration -> . ENT IDENTIFIANT = expr ;
    (8) ecrire -> . ECRIRE ( expr ) ;
    $end            reduce using rule 3 (listeInstructions -> instruction .)
    }               reduce using rule 3 (listeInstructions -> instruction .)
    TANTQUE         shift and go to state 8
    SI              shift and go to state 9
    IDENTIFIANT     shift and go to state 10
    BOOLEEN         shift and go to state 11
    ENT             shift and go to state 12
    ECRIRE          shift and go to state 13

    instruction                    shift and go to state 3
    listeInstructions              shift and go to state 14
    structure_conditionnelle       shift and go to state 4
    affectation                    shift and go to state 5
    declaration                    shift and go to state 6
    ecrire                         shift and go to state 7

state 4

    (4) instruction -> structure_conditionnelle .
    TANTQUE         reduce using rule 4 (instruction -> structure_conditionnelle .)
    SI              reduce using rule 4 (instruction -> structure_conditionnelle .)
    IDENTIFIANT     reduce using rule 4 (instruction -> structure_conditionnelle .)
    BOOLEEN         reduce using rule 4 (instruction -> structure_conditionnelle .)
    ENT             reduce using rule 4 (instruction -> structure_conditionnelle .)
    ECRIRE          reduce using rule 4 (instruction -> structure_conditionnelle .)
    $end            reduce using rule 4 (instruction -> structure_conditionnelle .)
    }               reduce using rule 4 (instruction -> structure_conditionnelle .)


state 5

    (5) instruction -> affectation .
    TANTQUE         reduce using rule 5 (instruction -> affectation .)
    SI              reduce using rule 5 (instruction -> affectation .)
    IDENTIFIANT     reduce using rule 5 (instruction -> affectation .)
    BOOLEEN         reduce using rule 5 (instruction -> affectation .)
    ENT             reduce using rule 5 (instruction -> affectation .)
    ECRIRE          reduce using rule 5 (instruction -> affectation .)
    $end            reduce using rule 5 (instruction -> affectation .)
    }               reduce using rule 5 (instruction -> affectation .)


state 6

    (6) instruction -> declaration .
    TANTQUE         reduce using rule 6 (instruction -> declaration .)
    SI              reduce using rule 6 (instruction -> declaration .)
    IDENTIFIANT     reduce using rule 6 (instruction -> declaration .)
    BOOLEEN         reduce using rule 6 (instruction -> declaration .)
    ENT             reduce using rule 6 (instruction -> declaration .)
    ECRIRE          reduce using rule 6 (instruction -> declaration .)
    $end            reduce using rule 6 (instruction -> declaration .)
    }               reduce using rule 6 (instruction -> declaration .)


state 7

    (7) instruction -> ecrire .
    TANTQUE         reduce using rule 7 (instruction -> ecrire .)
    SI              reduce using rule 7 (instruction -> ecrire .)
    IDENTIFIANT     reduce using rule 7 (instruction -> ecrire .)
    BOOLEEN         reduce using rule 7 (instruction -> ecrire .)
    ENT             reduce using rule 7 (instruction -> ecrire .)
    ECRIRE          reduce using rule 7 (instruction -> ecrire .)
    $end            reduce using rule 7 (instruction -> ecrire .)
    }               reduce using rule 7 (instruction -> ecrire .)


state 8

    (12) structure_conditionnelle -> TANTQUE . expr { listeInstructions }
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 15
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 9

    (13) structure_conditionnelle -> SI . expr ALORS { listeInstructions } SINON { listeInstructions }
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 22
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 10

    (11) affectation -> IDENTIFIANT . = expr ;
    =               shift and go to state 23


state 11

    (9) declaration -> BOOLEEN . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 24


state 12

    (10) declaration -> ENT . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 25


state 13

    (8) ecrire -> ECRIRE . ( expr ) ;
    (               shift and go to state 26


state 14

    (2) listeInstructions -> instruction listeInstructions .
    $end            reduce using rule 2 (listeInstructions -> instruction listeInstructions .)
    }               reduce using rule 2 (listeInstructions -> instruction listeInstructions .)


state 15

    (12) structure_conditionnelle -> TANTQUE expr . { listeInstructions }
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
    {               shift and go to state 27
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 16

    (14) expr -> NON . expr
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 35
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 17

    (20) expr -> term .
    (24) term -> term . DIV factor
    (25) term -> term . MULT factor
    {               reduce using rule 20 (expr -> term .)
    INFERIEUR_OU_EGAL reduce using rule 20 (expr -> term .)
    >               reduce using rule 20 (expr -> term .)
    <               reduce using rule 20 (expr -> term .)
    OU              reduce using rule 20 (expr -> term .)
    ET              reduce using rule 20 (expr -> term .)
    MINUS           reduce using rule 20 (expr -> term .)
    PLUS            reduce using rule 20 (expr -> term .)
    ALORS           reduce using rule 20 (expr -> term .)
    )               reduce using rule 20 (expr -> term .)
    ;               reduce using rule 20 (expr -> term .)
    DIV             shift and go to state 36
    MULT            shift and go to state 37


state 18

    (23) term -> factor .
    DIV             reduce using rule 23 (term -> factor .)
    MULT            reduce using rule 23 (term -> factor .)
    {               reduce using rule 23 (term -> factor .)
    INFERIEUR_OU_EGAL reduce using rule 23 (term -> factor .)
    >               reduce using rule 23 (term -> factor .)
    <               reduce using rule 23 (term -> factor .)
    OU              reduce using rule 23 (term -> factor .)
    ET              reduce using rule 23 (term -> factor .)
    MINUS           reduce using rule 23 (term -> factor .)
    PLUS            reduce using rule 23 (term -> factor .)
    ALORS           reduce using rule 23 (term -> factor .)
    )               reduce using rule 23 (term -> factor .)
    ;               reduce using rule 23 (term -> factor .)


state 19

    (26) factor -> ( . expr )
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 38
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 20

    (27) factor -> IDENTIFIANT .
    DIV             reduce using rule 27 (factor -> IDENTIFIANT .)
    MULT            reduce using rule 27 (factor -> IDENTIFIANT .)
    {               reduce using rule 27 (factor -> IDENTIFIANT .)
    INFERIEUR_OU_EGAL reduce using rule 27 (factor -> IDENTIFIANT .)
    >               reduce using rule 27 (factor -> IDENTIFIANT .)
    <               reduce using rule 27 (factor -> IDENTIFIANT .)
    OU              reduce using rule 27 (factor -> IDENTIFIANT .)
    ET              reduce using rule 27 (factor -> IDENTIFIANT .)
    MINUS           reduce using rule 27 (factor -> IDENTIFIANT .)
    PLUS            reduce using rule 27 (factor -> IDENTIFIANT .)
    ALORS           reduce using rule 27 (factor -> IDENTIFIANT .)
    )               reduce using rule 27 (factor -> IDENTIFIANT .)
    ;               reduce using rule 27 (factor -> IDENTIFIANT .)


state 21

    (28) factor -> ENTIER .
    DIV             reduce using rule 28 (factor -> ENTIER .)
    MULT            reduce using rule 28 (factor -> ENTIER .)
    {               reduce using rule 28 (factor -> ENTIER .)
    INFERIEUR_OU_EGAL reduce using rule 28 (factor -> ENTIER .)
    >               reduce using rule 28 (factor -> ENTIER .)
    <               reduce using rule 28 (factor -> ENTIER .)
    OU              reduce using rule 28 (factor -> ENTIER .)
    ET              reduce using rule 28 (factor -> ENTIER .)
    MINUS           reduce using rule 28 (factor -> ENTIER .)
    PLUS            reduce using rule 28 (factor -> ENTIER .)
    ALORS           reduce using rule 28 (factor -> ENTIER .)
    )               reduce using rule 28 (factor -> ENTIER .)
    ;               reduce using rule 28 (factor -> ENTIER .)


state 22

    (13) structure_conditionnelle -> SI expr . ALORS { listeInstructions } SINON { listeInstructions }
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
    ALORS           shift and go to state 39
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 23

    (11) affectation -> IDENTIFIANT = . expr ;
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 40
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 24

    (9) declaration -> BOOLEEN IDENTIFIANT . = expr ;
    =               shift and go to state 41


state 25

    (10) declaration -> ENT IDENTIFIANT . = expr ;
    =               shift and go to state 42


state 26

    (8) ecrire -> ECRIRE ( . expr ) ;
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 43
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 27

    (12) structure_conditionnelle -> TANTQUE expr { . listeInstructions }
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . structure_conditionnelle
    (5) instruction -> . affectation
    (6) instruction -> . declaration
    (7) instruction -> . ecrire
    (12) structure_conditionnelle -> . TANTQUE expr { listeInstructions }
    (13) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (11) affectation -> . IDENTIFIANT = expr ;
    (9) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (10) declaration -> . ENT IDENTIFIANT = expr ;
    (8) ecrire -> . ECRIRE ( expr ) ;
    TANTQUE         shift and go to state 8
    SI              shift and go to state 9
    IDENTIFIANT     shift and go to state 10
    BOOLEEN         shift and go to state 11
    ENT             shift and go to state 12
    ECRIRE          shift and go to state 13

    listeInstructions              shift and go to state 44
    instruction                    shift and go to state 3
    structure_conditionnelle       shift and go to state 4
    affectation                    shift and go to state 5
    declaration                    shift and go to state 6
    ecrire                         shift and go to state 7

state 28

    (15) expr -> expr INFERIEUR_OU_EGAL . expr
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 45
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 29

    (16) expr -> expr > . expr
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 46
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 30

    (17) expr -> expr < . expr
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 47
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 31

    (18) expr -> expr OU . expr
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 48
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 32

    (19) expr -> expr ET . expr
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 49
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 33

    (21) expr -> expr MINUS . term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    term                           shift and go to state 50
    factor                         shift and go to state 18

state 34

    (22) expr -> expr PLUS . term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    term                           shift and go to state 51
    factor                         shift and go to state 18

state 35

    (14) expr -> NON expr .
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
  ! shift/reduce conflict for INFERIEUR_OU_EGAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for OU resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    {               reduce using rule 14 (expr -> NON expr .)
    ALORS           reduce using rule 14 (expr -> NON expr .)
    )               reduce using rule 14 (expr -> NON expr .)
    ;               reduce using rule 14 (expr -> NON expr .)
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 36

    (24) term -> term DIV . factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    factor                         shift and go to state 52

state 37

    (25) term -> term MULT . factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    factor                         shift and go to state 53

state 38

    (26) factor -> ( expr . )
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
    )               shift and go to state 54
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 39

    (13) structure_conditionnelle -> SI expr ALORS . { listeInstructions } SINON { listeInstructions }
    {               shift and go to state 55


state 40

    (11) affectation -> IDENTIFIANT = expr . ;
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
    ;               shift and go to state 56
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 41

    (9) declaration -> BOOLEEN IDENTIFIANT = . expr ;
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 57
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 42

    (10) declaration -> ENT IDENTIFIANT = . expr ;
    (14) expr -> . NON expr
    (15) expr -> . expr INFERIEUR_OU_EGAL expr
    (16) expr -> . expr > expr
    (17) expr -> . expr < expr
    (18) expr -> . expr OU expr
    (19) expr -> . expr ET expr
    (20) expr -> . term
    (21) expr -> . expr MINUS term
    (22) expr -> . expr PLUS term
    (23) term -> . factor
    (24) term -> . term DIV factor
    (25) term -> . term MULT factor
    (26) factor -> . ( expr )
    (27) factor -> . IDENTIFIANT
    (28) factor -> . ENTIER
    NON             shift and go to state 16
    (               shift and go to state 19
    IDENTIFIANT     shift and go to state 20
    ENTIER          shift and go to state 21

    expr                           shift and go to state 58
    term                           shift and go to state 17
    factor                         shift and go to state 18

state 43

    (8) ecrire -> ECRIRE ( expr . ) ;
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
    )               shift and go to state 59
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 44

    (12) structure_conditionnelle -> TANTQUE expr { listeInstructions . }
    }               shift and go to state 60


state 45

    (15) expr -> expr INFERIEUR_OU_EGAL expr .
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
  ! shift/reduce conflict for INFERIEUR_OU_EGAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for OU resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    {               reduce using rule 15 (expr -> expr INFERIEUR_OU_EGAL expr .)
    ALORS           reduce using rule 15 (expr -> expr INFERIEUR_OU_EGAL expr .)
    )               reduce using rule 15 (expr -> expr INFERIEUR_OU_EGAL expr .)
    ;               reduce using rule 15 (expr -> expr INFERIEUR_OU_EGAL expr .)
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 46

    (16) expr -> expr > expr .
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
  ! shift/reduce conflict for INFERIEUR_OU_EGAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for OU resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    {               reduce using rule 16 (expr -> expr > expr .)
    ALORS           reduce using rule 16 (expr -> expr > expr .)
    )               reduce using rule 16 (expr -> expr > expr .)
    ;               reduce using rule 16 (expr -> expr > expr .)
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 47

    (17) expr -> expr < expr .
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
  ! shift/reduce conflict for INFERIEUR_OU_EGAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for OU resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    {               reduce using rule 17 (expr -> expr < expr .)
    ALORS           reduce using rule 17 (expr -> expr < expr .)
    )               reduce using rule 17 (expr -> expr < expr .)
    ;               reduce using rule 17 (expr -> expr < expr .)
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 48

    (18) expr -> expr OU expr .
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
  ! shift/reduce conflict for INFERIEUR_OU_EGAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for OU resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    {               reduce using rule 18 (expr -> expr OU expr .)
    ALORS           reduce using rule 18 (expr -> expr OU expr .)
    )               reduce using rule 18 (expr -> expr OU expr .)
    ;               reduce using rule 18 (expr -> expr OU expr .)
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 49

    (19) expr -> expr ET expr .
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
  ! shift/reduce conflict for INFERIEUR_OU_EGAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for OU resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    {               reduce using rule 19 (expr -> expr ET expr .)
    ALORS           reduce using rule 19 (expr -> expr ET expr .)
    )               reduce using rule 19 (expr -> expr ET expr .)
    ;               reduce using rule 19 (expr -> expr ET expr .)
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 50

    (21) expr -> expr MINUS term .
    (24) term -> term . DIV factor
    (25) term -> term . MULT factor
    {               reduce using rule 21 (expr -> expr MINUS term .)
    INFERIEUR_OU_EGAL reduce using rule 21 (expr -> expr MINUS term .)
    >               reduce using rule 21 (expr -> expr MINUS term .)
    <               reduce using rule 21 (expr -> expr MINUS term .)
    OU              reduce using rule 21 (expr -> expr MINUS term .)
    ET              reduce using rule 21 (expr -> expr MINUS term .)
    MINUS           reduce using rule 21 (expr -> expr MINUS term .)
    PLUS            reduce using rule 21 (expr -> expr MINUS term .)
    ALORS           reduce using rule 21 (expr -> expr MINUS term .)
    )               reduce using rule 21 (expr -> expr MINUS term .)
    ;               reduce using rule 21 (expr -> expr MINUS term .)
    DIV             shift and go to state 36
    MULT            shift and go to state 37


state 51

    (22) expr -> expr PLUS term .
    (24) term -> term . DIV factor
    (25) term -> term . MULT factor
    {               reduce using rule 22 (expr -> expr PLUS term .)
    INFERIEUR_OU_EGAL reduce using rule 22 (expr -> expr PLUS term .)
    >               reduce using rule 22 (expr -> expr PLUS term .)
    <               reduce using rule 22 (expr -> expr PLUS term .)
    OU              reduce using rule 22 (expr -> expr PLUS term .)
    ET              reduce using rule 22 (expr -> expr PLUS term .)
    MINUS           reduce using rule 22 (expr -> expr PLUS term .)
    PLUS            reduce using rule 22 (expr -> expr PLUS term .)
    ALORS           reduce using rule 22 (expr -> expr PLUS term .)
    )               reduce using rule 22 (expr -> expr PLUS term .)
    ;               reduce using rule 22 (expr -> expr PLUS term .)
    DIV             shift and go to state 36
    MULT            shift and go to state 37


state 52

    (24) term -> term DIV factor .
    DIV             reduce using rule 24 (term -> term DIV factor .)
    MULT            reduce using rule 24 (term -> term DIV factor .)
    {               reduce using rule 24 (term -> term DIV factor .)
    INFERIEUR_OU_EGAL reduce using rule 24 (term -> term DIV factor .)
    >               reduce using rule 24 (term -> term DIV factor .)
    <               reduce using rule 24 (term -> term DIV factor .)
    OU              reduce using rule 24 (term -> term DIV factor .)
    ET              reduce using rule 24 (term -> term DIV factor .)
    MINUS           reduce using rule 24 (term -> term DIV factor .)
    PLUS            reduce using rule 24 (term -> term DIV factor .)
    ALORS           reduce using rule 24 (term -> term DIV factor .)
    )               reduce using rule 24 (term -> term DIV factor .)
    ;               reduce using rule 24 (term -> term DIV factor .)


state 53

    (25) term -> term MULT factor .
    DIV             reduce using rule 25 (term -> term MULT factor .)
    MULT            reduce using rule 25 (term -> term MULT factor .)
    {               reduce using rule 25 (term -> term MULT factor .)
    INFERIEUR_OU_EGAL reduce using rule 25 (term -> term MULT factor .)
    >               reduce using rule 25 (term -> term MULT factor .)
    <               reduce using rule 25 (term -> term MULT factor .)
    OU              reduce using rule 25 (term -> term MULT factor .)
    ET              reduce using rule 25 (term -> term MULT factor .)
    MINUS           reduce using rule 25 (term -> term MULT factor .)
    PLUS            reduce using rule 25 (term -> term MULT factor .)
    ALORS           reduce using rule 25 (term -> term MULT factor .)
    )               reduce using rule 25 (term -> term MULT factor .)
    ;               reduce using rule 25 (term -> term MULT factor .)


state 54

    (26) factor -> ( expr ) .
    DIV             reduce using rule 26 (factor -> ( expr ) .)
    MULT            reduce using rule 26 (factor -> ( expr ) .)
    {               reduce using rule 26 (factor -> ( expr ) .)
    INFERIEUR_OU_EGAL reduce using rule 26 (factor -> ( expr ) .)
    >               reduce using rule 26 (factor -> ( expr ) .)
    <               reduce using rule 26 (factor -> ( expr ) .)
    OU              reduce using rule 26 (factor -> ( expr ) .)
    ET              reduce using rule 26 (factor -> ( expr ) .)
    MINUS           reduce using rule 26 (factor -> ( expr ) .)
    PLUS            reduce using rule 26 (factor -> ( expr ) .)
    ALORS           reduce using rule 26 (factor -> ( expr ) .)
    )               reduce using rule 26 (factor -> ( expr ) .)
    ;               reduce using rule 26 (factor -> ( expr ) .)


state 55

    (13) structure_conditionnelle -> SI expr ALORS { . listeInstructions } SINON { listeInstructions }
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . structure_conditionnelle
    (5) instruction -> . affectation
    (6) instruction -> . declaration
    (7) instruction -> . ecrire
    (12) structure_conditionnelle -> . TANTQUE expr { listeInstructions }
    (13) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (11) affectation -> . IDENTIFIANT = expr ;
    (9) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (10) declaration -> . ENT IDENTIFIANT = expr ;
    (8) ecrire -> . ECRIRE ( expr ) ;
    TANTQUE         shift and go to state 8
    SI              shift and go to state 9
    IDENTIFIANT     shift and go to state 10
    BOOLEEN         shift and go to state 11
    ENT             shift and go to state 12
    ECRIRE          shift and go to state 13

    listeInstructions              shift and go to state 61
    instruction                    shift and go to state 3
    structure_conditionnelle       shift and go to state 4
    affectation                    shift and go to state 5
    declaration                    shift and go to state 6
    ecrire                         shift and go to state 7

state 56

    (11) affectation -> IDENTIFIANT = expr ; .
    TANTQUE         reduce using rule 11 (affectation -> IDENTIFIANT = expr ; .)
    SI              reduce using rule 11 (affectation -> IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 11 (affectation -> IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 11 (affectation -> IDENTIFIANT = expr ; .)
    ENT             reduce using rule 11 (affectation -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 11 (affectation -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 11 (affectation -> IDENTIFIANT = expr ; .)
    }               reduce using rule 11 (affectation -> IDENTIFIANT = expr ; .)


state 57

    (9) declaration -> BOOLEEN IDENTIFIANT = expr . ;
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
    ;               shift and go to state 62
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 58

    (10) declaration -> ENT IDENTIFIANT = expr . ;
    (15) expr -> expr . INFERIEUR_OU_EGAL expr
    (16) expr -> expr . > expr
    (17) expr -> expr . < expr
    (18) expr -> expr . OU expr
    (19) expr -> expr . ET expr
    (21) expr -> expr . MINUS term
    (22) expr -> expr . PLUS term
    ;               shift and go to state 63
    INFERIEUR_OU_EGAL shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    OU              shift and go to state 31
    ET              shift and go to state 32
    MINUS           shift and go to state 33
    PLUS            shift and go to state 34


state 59

    (8) ecrire -> ECRIRE ( expr ) . ;
    ;               shift and go to state 64


state 60

    (12) structure_conditionnelle -> TANTQUE expr { listeInstructions } .
    TANTQUE         reduce using rule 12 (structure_conditionnelle -> TANTQUE expr { listeInstructions } .)
    SI              reduce using rule 12 (structure_conditionnelle -> TANTQUE expr { listeInstructions } .)
    IDENTIFIANT     reduce using rule 12 (structure_conditionnelle -> TANTQUE expr { listeInstructions } .)
    BOOLEEN         reduce using rule 12 (structure_conditionnelle -> TANTQUE expr { listeInstructions } .)
    ENT             reduce using rule 12 (structure_conditionnelle -> TANTQUE expr { listeInstructions } .)
    ECRIRE          reduce using rule 12 (structure_conditionnelle -> TANTQUE expr { listeInstructions } .)
    $end            reduce using rule 12 (structure_conditionnelle -> TANTQUE expr { listeInstructions } .)
    }               reduce using rule 12 (structure_conditionnelle -> TANTQUE expr { listeInstructions } .)


state 61

    (13) structure_conditionnelle -> SI expr ALORS { listeInstructions . } SINON { listeInstructions }
    }               shift and go to state 65


state 62

    (9) declaration -> BOOLEEN IDENTIFIANT = expr ; .
    TANTQUE         reduce using rule 9 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    SI              reduce using rule 9 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 9 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 9 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    ENT             reduce using rule 9 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 9 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    $end            reduce using rule 9 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)
    }               reduce using rule 9 (declaration -> BOOLEEN IDENTIFIANT = expr ; .)


state 63

    (10) declaration -> ENT IDENTIFIANT = expr ; .
    TANTQUE         reduce using rule 10 (declaration -> ENT IDENTIFIANT = expr ; .)
    SI              reduce using rule 10 (declaration -> ENT IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 10 (declaration -> ENT IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 10 (declaration -> ENT IDENTIFIANT = expr ; .)
    ENT             reduce using rule 10 (declaration -> ENT IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 10 (declaration -> ENT IDENTIFIANT = expr ; .)
    $end            reduce using rule 10 (declaration -> ENT IDENTIFIANT = expr ; .)
    }               reduce using rule 10 (declaration -> ENT IDENTIFIANT = expr ; .)


state 64

    (8) ecrire -> ECRIRE ( expr ) ; .
    TANTQUE         reduce using rule 8 (ecrire -> ECRIRE ( expr ) ; .)
    SI              reduce using rule 8 (ecrire -> ECRIRE ( expr ) ; .)
    IDENTIFIANT     reduce using rule 8 (ecrire -> ECRIRE ( expr ) ; .)
    BOOLEEN         reduce using rule 8 (ecrire -> ECRIRE ( expr ) ; .)
    ENT             reduce using rule 8 (ecrire -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 8 (ecrire -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 8 (ecrire -> ECRIRE ( expr ) ; .)
    }               reduce using rule 8 (ecrire -> ECRIRE ( expr ) ; .)


state 65

    (13) structure_conditionnelle -> SI expr ALORS { listeInstructions } . SINON { listeInstructions }
    SINON           shift and go to state 66


state 66

    (13) structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON . { listeInstructions }
    {               shift and go to state 67


state 67

    (13) structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { . listeInstructions }
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . structure_conditionnelle
    (5) instruction -> . affectation
    (6) instruction -> . declaration
    (7) instruction -> . ecrire
    (12) structure_conditionnelle -> . TANTQUE expr { listeInstructions }
    (13) structure_conditionnelle -> . SI expr ALORS { listeInstructions } SINON { listeInstructions }
    (11) affectation -> . IDENTIFIANT = expr ;
    (9) declaration -> . BOOLEEN IDENTIFIANT = expr ;
    (10) declaration -> . ENT IDENTIFIANT = expr ;
    (8) ecrire -> . ECRIRE ( expr ) ;
    TANTQUE         shift and go to state 8
    SI              shift and go to state 9
    IDENTIFIANT     shift and go to state 10
    BOOLEEN         shift and go to state 11
    ENT             shift and go to state 12
    ECRIRE          shift and go to state 13

    listeInstructions              shift and go to state 68
    instruction                    shift and go to state 3
    structure_conditionnelle       shift and go to state 4
    affectation                    shift and go to state 5
    declaration                    shift and go to state 6
    ecrire                         shift and go to state 7

state 68

    (13) structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions . }
    }               shift and go to state 69


state 69

    (13) structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .
    TANTQUE         reduce using rule 13 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    SI              reduce using rule 13 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    IDENTIFIANT     reduce using rule 13 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    BOOLEEN         reduce using rule 13 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    ENT             reduce using rule 13 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    ECRIRE          reduce using rule 13 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    $end            reduce using rule 13 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)
    }               reduce using rule 13 (structure_conditionnelle -> SI expr ALORS { listeInstructions } SINON { listeInstructions } .)


Conflicts:

shift/reduce conflict for INFERIEUR_OU_EGAL in state 35 resolved as shift
shift/reduce conflict for > in state 35 resolved as shift
shift/reduce conflict for < in state 35 resolved as shift
shift/reduce conflict for OU in state 35 resolved as shift
shift/reduce conflict for ET in state 35 resolved as shift
shift/reduce conflict for MINUS in state 35 resolved as shift
shift/reduce conflict for PLUS in state 35 resolved as shift
shift/reduce conflict for INFERIEUR_OU_EGAL in state 45 resolved as shift
shift/reduce conflict for > in state 45 resolved as shift
shift/reduce conflict for < in state 45 resolved as shift
shift/reduce conflict for OU in state 45 resolved as shift
shift/reduce conflict for ET in state 45 resolved as shift
shift/reduce conflict for MINUS in state 45 resolved as shift
shift/reduce conflict for PLUS in state 45 resolved as shift
shift/reduce conflict for INFERIEUR_OU_EGAL in state 46 resolved as shift
shift/reduce conflict for > in state 46 resolved as shift
shift/reduce conflict for < in state 46 resolved as shift
shift/reduce conflict for OU in state 46 resolved as shift
shift/reduce conflict for ET in state 46 resolved as shift
shift/reduce conflict for MINUS in state 46 resolved as shift
shift/reduce conflict for PLUS in state 46 resolved as shift
shift/reduce conflict for INFERIEUR_OU_EGAL in state 47 resolved as shift
shift/reduce conflict for > in state 47 resolved as shift
shift/reduce conflict for < in state 47 resolved as shift
shift/reduce conflict for OU in state 47 resolved as shift
shift/reduce conflict for ET in state 47 resolved as shift
shift/reduce conflict for MINUS in state 47 resolved as shift
shift/reduce conflict for PLUS in state 47 resolved as shift
shift/reduce conflict for INFERIEUR_OU_EGAL in state 48 resolved as shift
shift/reduce conflict for > in state 48 resolved as shift
shift/reduce conflict for < in state 48 resolved as shift
shift/reduce conflict for OU in state 48 resolved as shift
shift/reduce conflict for ET in state 48 resolved as shift
shift/reduce conflict for MINUS in state 48 resolved as shift
shift/reduce conflict for PLUS in state 48 resolved as shift
shift/reduce conflict for INFERIEUR_OU_EGAL in state 49 resolved as shift
shift/reduce conflict for > in state 49 resolved as shift
shift/reduce conflict for < in state 49 resolved as shift
shift/reduce conflict for OU in state 49 resolved as shift
shift/reduce conflict for ET in state 49 resolved as shift
shift/reduce conflict for MINUS in state 49 resolved as shift
shift/reduce conflict for PLUS in state 49 resolved as shift