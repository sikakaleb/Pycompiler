Grammar:

Rule 0     S' -> statement
Rule 1     statement -> prog
Rule 2     prog -> listeFonctions listeInstructions
Rule 3     prog -> listeFonctions
Rule 4     prog -> listeInstructions
Rule 5     listeFonctions -> listeFonctions fonction_declaration_without_parm
Rule 6     listeFonctions -> listeFonctions fonction_declaration
Rule 7     listeFonctions -> fonction_declaration
Rule 8     listeFonctions -> fonction_declaration_without_parm
Rule 9     listeInstructions -> instruction
Rule 10    listeInstructions -> listeInstructions instruction
Rule 11    instruction -> appel_fonction_instr_without_parm
Rule 12    instruction -> appel_fonction_instr
Rule 13    instruction -> retourner
Rule 14    instruction -> boucle
Rule 15    instruction -> condition
Rule 16    instruction -> affectation
Rule 17    instruction -> declaration
Rule 18    instruction -> ecrire
Rule 19    ecrire -> ECRIRE ( expr ) ;
Rule 20    declaration -> type IDENTIFIANT ;
Rule 21    declaration -> type IDENTIFIANT = expr ;
Rule 22    affectation -> IDENTIFIANT = expr ;
Rule 23    condition -> SI ( expr ) { listeInstructions } suite_sinosi
Rule 24    suite_sinosi -> <empty>
Rule 25    suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi
Rule 26    suite_sinosi -> SINON { listeInstructions }
Rule 27    boucle -> TANTQUE ( expr ) { listeInstructions }
Rule 28    retourner -> RETOURNER expr ;
Rule 29    retourner -> retourner
Rule 30    appel_fonction_instr -> IDENTIFIANT ( arg_list ) ;
Rule 31    appel_fonction_expr -> IDENTIFIANT ( arg_list )
Rule 32    appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ;
Rule 33    appel_fonction_expr_without_parm -> IDENTIFIANT ( )
Rule 34    fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions }
Rule 35    fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions }
Rule 36    param_list -> param_list , param
Rule 37    param_list -> param
Rule 38    param -> type IDENTIFIANT
Rule 39    expr -> expr ET expr  [precedence=left, level=5]
Rule 40    expr -> expr COMPARATEUR expr  [precedence=nonassoc, level=7]
Rule 41    expr -> expr MODULO term  [precedence=left, level=3]
Rule 42    expr -> term
Rule 43    expr -> term MINUS expr  [precedence=left, level=4]
Rule 44    expr -> term PLUS expr  [precedence=left, level=4]
Rule 45    term -> factor
Rule 46    term -> term DIV factor  [precedence=left, level=3]
Rule 47    term -> term MULT factor  [precedence=left, level=3]
Rule 48    factor -> LIRE ( )
Rule 49    factor -> MINUS factor  [precedence=nonassoc, level=2]
Rule 50    factor -> NON expr  [precedence=nonassoc, level=1]
Rule 51    factor -> factor OU expr  [precedence=left, level=6]
Rule 52    factor -> IDENTIFIANT
Rule 53    factor -> ( expr )
Rule 54    factor -> BOOLEEN_LITERAL
Rule 55    factor -> ENTIER
Rule 56    factor -> appel_fonction_expr_without_parm
Rule 57    factor -> appel_fonction_expr
Rule 58    type -> ENT
Rule 59    type -> BOOLEEN
Rule 60    arg_list -> arg_list , expr
Rule 61    arg_list -> expr

Unused terminals:

    ALORS
    UMINUS

Terminals, with rules where they appear:

(                    : 19 23 25 27 30 31 32 33 34 35 48 53
)                    : 19 23 25 27 30 31 32 33 34 35 48 53
,                    : 36 60
;                    : 19 20 21 22 28 30 32
=                    : 21 22
ALORS                : 
BOOLEEN              : 59
BOOLEEN_LITERAL      : 54
COMPARATEUR          : 40
DIV                  : 46
ECRIRE               : 19
ENT                  : 58
ENTIER               : 55
ET                   : 39
IDENTIFIANT          : 20 21 22 30 31 32 33 34 35 38 52
LIRE                 : 48
MINUS                : 43 49
MODULO               : 41
MULT                 : 47
NON                  : 50
OU                   : 51
PLUS                 : 44
RETOURNER            : 28
SI                   : 23 25
SINON                : 25 26
TANTQUE              : 27
UMINUS               : 
error                : 
{                    : 23 25 26 27 34 35
}                    : 23 25 26 27 34 35

Nonterminals, with rules where they appear:

affectation          : 16
appel_fonction_expr  : 57
appel_fonction_expr_without_parm : 56
appel_fonction_instr : 12
appel_fonction_instr_without_parm : 11
arg_list             : 30 31 60
boucle               : 14
condition            : 15
declaration          : 17
ecrire               : 18
expr                 : 19 21 22 23 25 27 28 39 39 40 40 41 43 44 50 51 53 60 61
factor               : 45 46 47 49 51
fonction_declaration : 6 7
fonction_declaration_without_parm : 5 8
instruction          : 9 10
listeFonctions       : 2 3 5 6
listeInstructions    : 2 4 10 23 25 26 27 34 35
param                : 36 37
param_list           : 34 36
prog                 : 1
retourner            : 13 29
statement            : 0
suite_sinosi         : 23 25
term                 : 41 42 43 44 46 47
type                 : 20 21 34 35 38


state 0

    (0) S' -> . statement
    (1) statement -> . prog
    (2) prog -> . listeFonctions listeInstructions
    (3) prog -> . listeFonctions
    (4) prog -> . listeInstructions
    (5) listeFonctions -> . listeFonctions fonction_declaration_without_parm
    (6) listeFonctions -> . listeFonctions fonction_declaration
    (7) listeFonctions -> . fonction_declaration
    (8) listeFonctions -> . fonction_declaration_without_parm
    (9) listeInstructions -> . instruction
    (10) listeInstructions -> . listeInstructions instruction
    (34) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (35) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23

    statement                      shift and go to state 1
    prog                           shift and go to state 2
    listeFonctions                 shift and go to state 3
    listeInstructions              shift and go to state 4
    fonction_declaration_without_parm shift and go to state 5
    fonction_declaration           shift and go to state 6
    instruction                    shift and go to state 7
    type                           shift and go to state 8
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17

state 1

    (0) S' -> statement .


state 2

    (1) statement -> prog .
    $end            reduce using rule 1 (statement -> prog .)


state 3

    (2) prog -> listeFonctions . listeInstructions
    (3) prog -> listeFonctions .
    (5) listeFonctions -> listeFonctions . fonction_declaration_without_parm
    (6) listeFonctions -> listeFonctions . fonction_declaration
    (9) listeInstructions -> . instruction
    (10) listeInstructions -> . listeInstructions instruction
    (35) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (34) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    $end            reduce using rule 3 (prog -> listeFonctions .)
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23

    listeInstructions              shift and go to state 24
    fonction_declaration_without_parm shift and go to state 25
    fonction_declaration           shift and go to state 26
    instruction                    shift and go to state 7
    type                           shift and go to state 27
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17

state 4

    (4) prog -> listeInstructions .
    (10) listeInstructions -> listeInstructions . instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    $end            reduce using rule 4 (prog -> listeInstructions .)
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    instruction                    shift and go to state 28
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 5

    (8) listeFonctions -> fonction_declaration_without_parm .
    ENT             reduce using rule 8 (listeFonctions -> fonction_declaration_without_parm .)
    BOOLEEN         reduce using rule 8 (listeFonctions -> fonction_declaration_without_parm .)
    IDENTIFIANT     reduce using rule 8 (listeFonctions -> fonction_declaration_without_parm .)
    RETOURNER       reduce using rule 8 (listeFonctions -> fonction_declaration_without_parm .)
    TANTQUE         reduce using rule 8 (listeFonctions -> fonction_declaration_without_parm .)
    SI              reduce using rule 8 (listeFonctions -> fonction_declaration_without_parm .)
    ECRIRE          reduce using rule 8 (listeFonctions -> fonction_declaration_without_parm .)
    $end            reduce using rule 8 (listeFonctions -> fonction_declaration_without_parm .)


state 6

    (7) listeFonctions -> fonction_declaration .
    ENT             reduce using rule 7 (listeFonctions -> fonction_declaration .)
    BOOLEEN         reduce using rule 7 (listeFonctions -> fonction_declaration .)
    IDENTIFIANT     reduce using rule 7 (listeFonctions -> fonction_declaration .)
    RETOURNER       reduce using rule 7 (listeFonctions -> fonction_declaration .)
    TANTQUE         reduce using rule 7 (listeFonctions -> fonction_declaration .)
    SI              reduce using rule 7 (listeFonctions -> fonction_declaration .)
    ECRIRE          reduce using rule 7 (listeFonctions -> fonction_declaration .)
    $end            reduce using rule 7 (listeFonctions -> fonction_declaration .)


state 7

    (9) listeInstructions -> instruction .
    IDENTIFIANT     reduce using rule 9 (listeInstructions -> instruction .)
    RETOURNER       reduce using rule 9 (listeInstructions -> instruction .)
    TANTQUE         reduce using rule 9 (listeInstructions -> instruction .)
    SI              reduce using rule 9 (listeInstructions -> instruction .)
    ECRIRE          reduce using rule 9 (listeInstructions -> instruction .)
    ENT             reduce using rule 9 (listeInstructions -> instruction .)
    BOOLEEN         reduce using rule 9 (listeInstructions -> instruction .)
    $end            reduce using rule 9 (listeInstructions -> instruction .)
    }               reduce using rule 9 (listeInstructions -> instruction .)


state 8

    (34) fonction_declaration -> type . IDENTIFIANT ( param_list ) { listeInstructions }
    (35) fonction_declaration_without_parm -> type . IDENTIFIANT ( ) { listeInstructions }
    (20) declaration -> type . IDENTIFIANT ;
    (21) declaration -> type . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 30


state 9

    (32) appel_fonction_instr_without_parm -> IDENTIFIANT . ( ) ;
    (30) appel_fonction_instr -> IDENTIFIANT . ( arg_list ) ;
    (22) affectation -> IDENTIFIANT . = expr ;
    (               shift and go to state 31
    =               shift and go to state 32


state 10

    (11) instruction -> appel_fonction_instr_without_parm .
    IDENTIFIANT     reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)
    RETOURNER       reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)
    TANTQUE         reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)
    SI              reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)
    ECRIRE          reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)
    ENT             reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)
    BOOLEEN         reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)
    $end            reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)
    }               reduce using rule 11 (instruction -> appel_fonction_instr_without_parm .)


state 11

    (12) instruction -> appel_fonction_instr .
    IDENTIFIANT     reduce using rule 12 (instruction -> appel_fonction_instr .)
    RETOURNER       reduce using rule 12 (instruction -> appel_fonction_instr .)
    TANTQUE         reduce using rule 12 (instruction -> appel_fonction_instr .)
    SI              reduce using rule 12 (instruction -> appel_fonction_instr .)
    ECRIRE          reduce using rule 12 (instruction -> appel_fonction_instr .)
    ENT             reduce using rule 12 (instruction -> appel_fonction_instr .)
    BOOLEEN         reduce using rule 12 (instruction -> appel_fonction_instr .)
    $end            reduce using rule 12 (instruction -> appel_fonction_instr .)
    }               reduce using rule 12 (instruction -> appel_fonction_instr .)


state 12

    (13) instruction -> retourner .
    (29) retourner -> retourner .
  ! reduce/reduce conflict for IDENTIFIANT resolved using rule 13 (instruction -> retourner .)
  ! reduce/reduce conflict for RETOURNER resolved using rule 13 (instruction -> retourner .)
  ! reduce/reduce conflict for TANTQUE resolved using rule 13 (instruction -> retourner .)
  ! reduce/reduce conflict for SI resolved using rule 13 (instruction -> retourner .)
  ! reduce/reduce conflict for ECRIRE resolved using rule 13 (instruction -> retourner .)
  ! reduce/reduce conflict for ENT resolved using rule 13 (instruction -> retourner .)
  ! reduce/reduce conflict for BOOLEEN resolved using rule 13 (instruction -> retourner .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> retourner .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> retourner .)
    IDENTIFIANT     reduce using rule 13 (instruction -> retourner .)
    RETOURNER       reduce using rule 13 (instruction -> retourner .)
    TANTQUE         reduce using rule 13 (instruction -> retourner .)
    SI              reduce using rule 13 (instruction -> retourner .)
    ECRIRE          reduce using rule 13 (instruction -> retourner .)
    ENT             reduce using rule 13 (instruction -> retourner .)
    BOOLEEN         reduce using rule 13 (instruction -> retourner .)
    $end            reduce using rule 13 (instruction -> retourner .)
    }               reduce using rule 13 (instruction -> retourner .)


state 13

    (14) instruction -> boucle .
    IDENTIFIANT     reduce using rule 14 (instruction -> boucle .)
    RETOURNER       reduce using rule 14 (instruction -> boucle .)
    TANTQUE         reduce using rule 14 (instruction -> boucle .)
    SI              reduce using rule 14 (instruction -> boucle .)
    ECRIRE          reduce using rule 14 (instruction -> boucle .)
    ENT             reduce using rule 14 (instruction -> boucle .)
    BOOLEEN         reduce using rule 14 (instruction -> boucle .)
    $end            reduce using rule 14 (instruction -> boucle .)
    }               reduce using rule 14 (instruction -> boucle .)


state 14

    (15) instruction -> condition .
    IDENTIFIANT     reduce using rule 15 (instruction -> condition .)
    RETOURNER       reduce using rule 15 (instruction -> condition .)
    TANTQUE         reduce using rule 15 (instruction -> condition .)
    SI              reduce using rule 15 (instruction -> condition .)
    ECRIRE          reduce using rule 15 (instruction -> condition .)
    ENT             reduce using rule 15 (instruction -> condition .)
    BOOLEEN         reduce using rule 15 (instruction -> condition .)
    $end            reduce using rule 15 (instruction -> condition .)
    }               reduce using rule 15 (instruction -> condition .)


state 15

    (16) instruction -> affectation .
    IDENTIFIANT     reduce using rule 16 (instruction -> affectation .)
    RETOURNER       reduce using rule 16 (instruction -> affectation .)
    TANTQUE         reduce using rule 16 (instruction -> affectation .)
    SI              reduce using rule 16 (instruction -> affectation .)
    ECRIRE          reduce using rule 16 (instruction -> affectation .)
    ENT             reduce using rule 16 (instruction -> affectation .)
    BOOLEEN         reduce using rule 16 (instruction -> affectation .)
    $end            reduce using rule 16 (instruction -> affectation .)
    }               reduce using rule 16 (instruction -> affectation .)


state 16

    (17) instruction -> declaration .
    IDENTIFIANT     reduce using rule 17 (instruction -> declaration .)
    RETOURNER       reduce using rule 17 (instruction -> declaration .)
    TANTQUE         reduce using rule 17 (instruction -> declaration .)
    SI              reduce using rule 17 (instruction -> declaration .)
    ECRIRE          reduce using rule 17 (instruction -> declaration .)
    ENT             reduce using rule 17 (instruction -> declaration .)
    BOOLEEN         reduce using rule 17 (instruction -> declaration .)
    $end            reduce using rule 17 (instruction -> declaration .)
    }               reduce using rule 17 (instruction -> declaration .)


state 17

    (18) instruction -> ecrire .
    IDENTIFIANT     reduce using rule 18 (instruction -> ecrire .)
    RETOURNER       reduce using rule 18 (instruction -> ecrire .)
    TANTQUE         reduce using rule 18 (instruction -> ecrire .)
    SI              reduce using rule 18 (instruction -> ecrire .)
    ECRIRE          reduce using rule 18 (instruction -> ecrire .)
    ENT             reduce using rule 18 (instruction -> ecrire .)
    BOOLEEN         reduce using rule 18 (instruction -> ecrire .)
    $end            reduce using rule 18 (instruction -> ecrire .)
    }               reduce using rule 18 (instruction -> ecrire .)


state 18

    (58) type -> ENT .
    IDENTIFIANT     reduce using rule 58 (type -> ENT .)


state 19

    (59) type -> BOOLEEN .
    IDENTIFIANT     reduce using rule 59 (type -> BOOLEEN .)


state 20

    (28) retourner -> RETOURNER . expr ;
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 33
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 21

    (27) boucle -> TANTQUE . ( expr ) { listeInstructions }
    (               shift and go to state 45


state 22

    (23) condition -> SI . ( expr ) { listeInstructions } suite_sinosi
    (               shift and go to state 46


state 23

    (19) ecrire -> ECRIRE . ( expr ) ;
    (               shift and go to state 47


state 24

    (2) prog -> listeFonctions listeInstructions .
    (10) listeInstructions -> listeInstructions . instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    $end            reduce using rule 2 (prog -> listeFonctions listeInstructions .)
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    instruction                    shift and go to state 28
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 25

    (5) listeFonctions -> listeFonctions fonction_declaration_without_parm .
    ENT             reduce using rule 5 (listeFonctions -> listeFonctions fonction_declaration_without_parm .)
    BOOLEEN         reduce using rule 5 (listeFonctions -> listeFonctions fonction_declaration_without_parm .)
    IDENTIFIANT     reduce using rule 5 (listeFonctions -> listeFonctions fonction_declaration_without_parm .)
    RETOURNER       reduce using rule 5 (listeFonctions -> listeFonctions fonction_declaration_without_parm .)
    TANTQUE         reduce using rule 5 (listeFonctions -> listeFonctions fonction_declaration_without_parm .)
    SI              reduce using rule 5 (listeFonctions -> listeFonctions fonction_declaration_without_parm .)
    ECRIRE          reduce using rule 5 (listeFonctions -> listeFonctions fonction_declaration_without_parm .)
    $end            reduce using rule 5 (listeFonctions -> listeFonctions fonction_declaration_without_parm .)


state 26

    (6) listeFonctions -> listeFonctions fonction_declaration .
    ENT             reduce using rule 6 (listeFonctions -> listeFonctions fonction_declaration .)
    BOOLEEN         reduce using rule 6 (listeFonctions -> listeFonctions fonction_declaration .)
    IDENTIFIANT     reduce using rule 6 (listeFonctions -> listeFonctions fonction_declaration .)
    RETOURNER       reduce using rule 6 (listeFonctions -> listeFonctions fonction_declaration .)
    TANTQUE         reduce using rule 6 (listeFonctions -> listeFonctions fonction_declaration .)
    SI              reduce using rule 6 (listeFonctions -> listeFonctions fonction_declaration .)
    ECRIRE          reduce using rule 6 (listeFonctions -> listeFonctions fonction_declaration .)
    $end            reduce using rule 6 (listeFonctions -> listeFonctions fonction_declaration .)


state 27

    (35) fonction_declaration_without_parm -> type . IDENTIFIANT ( ) { listeInstructions }
    (34) fonction_declaration -> type . IDENTIFIANT ( param_list ) { listeInstructions }
    (20) declaration -> type . IDENTIFIANT ;
    (21) declaration -> type . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 48


state 28

    (10) listeInstructions -> listeInstructions instruction .
    IDENTIFIANT     reduce using rule 10 (listeInstructions -> listeInstructions instruction .)
    RETOURNER       reduce using rule 10 (listeInstructions -> listeInstructions instruction .)
    TANTQUE         reduce using rule 10 (listeInstructions -> listeInstructions instruction .)
    SI              reduce using rule 10 (listeInstructions -> listeInstructions instruction .)
    ECRIRE          reduce using rule 10 (listeInstructions -> listeInstructions instruction .)
    ENT             reduce using rule 10 (listeInstructions -> listeInstructions instruction .)
    BOOLEEN         reduce using rule 10 (listeInstructions -> listeInstructions instruction .)
    $end            reduce using rule 10 (listeInstructions -> listeInstructions instruction .)
    }               reduce using rule 10 (listeInstructions -> listeInstructions instruction .)


state 29

    (20) declaration -> type . IDENTIFIANT ;
    (21) declaration -> type . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 49


state 30

    (34) fonction_declaration -> type IDENTIFIANT . ( param_list ) { listeInstructions }
    (35) fonction_declaration_without_parm -> type IDENTIFIANT . ( ) { listeInstructions }
    (20) declaration -> type IDENTIFIANT . ;
    (21) declaration -> type IDENTIFIANT . = expr ;
    (               shift and go to state 50
    ;               shift and go to state 51
    =               shift and go to state 52


state 31

    (32) appel_fonction_instr_without_parm -> IDENTIFIANT ( . ) ;
    (30) appel_fonction_instr -> IDENTIFIANT ( . arg_list ) ;
    (60) arg_list -> . arg_list , expr
    (61) arg_list -> . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    )               shift and go to state 53
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    arg_list                       shift and go to state 54
    expr                           shift and go to state 55
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 32

    (22) affectation -> IDENTIFIANT = . expr ;
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 56
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 33

    (28) retourner -> RETOURNER expr . ;
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    ;               shift and go to state 57
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 34

    (42) expr -> term .
    (43) expr -> term . MINUS expr
    (44) expr -> term . PLUS expr
    (46) term -> term . DIV factor
    (47) term -> term . MULT factor
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
    ;               reduce using rule 42 (expr -> term .)
    ET              reduce using rule 42 (expr -> term .)
    COMPARATEUR     reduce using rule 42 (expr -> term .)
    MODULO          reduce using rule 42 (expr -> term .)
    )               reduce using rule 42 (expr -> term .)
    ,               reduce using rule 42 (expr -> term .)
    OU              reduce using rule 42 (expr -> term .)
    MINUS           shift and go to state 61
    PLUS            shift and go to state 62
    DIV             shift and go to state 63
    MULT            shift and go to state 64


state 35

    (49) factor -> MINUS . factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    factor                         shift and go to state 65
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 36

    (45) term -> factor .
    (51) factor -> factor . OU expr
  ! shift/reduce conflict for OU resolved as shift
    MINUS           reduce using rule 45 (term -> factor .)
    PLUS            reduce using rule 45 (term -> factor .)
    DIV             reduce using rule 45 (term -> factor .)
    MULT            reduce using rule 45 (term -> factor .)
    ;               reduce using rule 45 (term -> factor .)
    ET              reduce using rule 45 (term -> factor .)
    COMPARATEUR     reduce using rule 45 (term -> factor .)
    MODULO          reduce using rule 45 (term -> factor .)
    )               reduce using rule 45 (term -> factor .)
    ,               reduce using rule 45 (term -> factor .)
    OU              shift and go to state 66


state 37

    (48) factor -> LIRE . ( )
    (               shift and go to state 67


state 38

    (53) factor -> ( . expr )
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 68
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 39

    (50) factor -> NON . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 69
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 40

    (52) factor -> IDENTIFIANT .
    (33) appel_fonction_expr_without_parm -> IDENTIFIANT . ( )
    (31) appel_fonction_expr -> IDENTIFIANT . ( arg_list )
    OU              reduce using rule 52 (factor -> IDENTIFIANT .)
    MINUS           reduce using rule 52 (factor -> IDENTIFIANT .)
    PLUS            reduce using rule 52 (factor -> IDENTIFIANT .)
    DIV             reduce using rule 52 (factor -> IDENTIFIANT .)
    MULT            reduce using rule 52 (factor -> IDENTIFIANT .)
    ;               reduce using rule 52 (factor -> IDENTIFIANT .)
    ET              reduce using rule 52 (factor -> IDENTIFIANT .)
    COMPARATEUR     reduce using rule 52 (factor -> IDENTIFIANT .)
    MODULO          reduce using rule 52 (factor -> IDENTIFIANT .)
    )               reduce using rule 52 (factor -> IDENTIFIANT .)
    ,               reduce using rule 52 (factor -> IDENTIFIANT .)
    (               shift and go to state 70


state 41

    (54) factor -> BOOLEEN_LITERAL .
    OU              reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    MINUS           reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    PLUS            reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    DIV             reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    MULT            reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    ;               reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    ET              reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    COMPARATEUR     reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    MODULO          reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    )               reduce using rule 54 (factor -> BOOLEEN_LITERAL .)
    ,               reduce using rule 54 (factor -> BOOLEEN_LITERAL .)


state 42

    (55) factor -> ENTIER .
    OU              reduce using rule 55 (factor -> ENTIER .)
    MINUS           reduce using rule 55 (factor -> ENTIER .)
    PLUS            reduce using rule 55 (factor -> ENTIER .)
    DIV             reduce using rule 55 (factor -> ENTIER .)
    MULT            reduce using rule 55 (factor -> ENTIER .)
    ;               reduce using rule 55 (factor -> ENTIER .)
    ET              reduce using rule 55 (factor -> ENTIER .)
    COMPARATEUR     reduce using rule 55 (factor -> ENTIER .)
    MODULO          reduce using rule 55 (factor -> ENTIER .)
    )               reduce using rule 55 (factor -> ENTIER .)
    ,               reduce using rule 55 (factor -> ENTIER .)


state 43

    (56) factor -> appel_fonction_expr_without_parm .
    OU              reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    MINUS           reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    PLUS            reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    DIV             reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    MULT            reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    ;               reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    ET              reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    COMPARATEUR     reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    MODULO          reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    )               reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)
    ,               reduce using rule 56 (factor -> appel_fonction_expr_without_parm .)


state 44

    (57) factor -> appel_fonction_expr .
    OU              reduce using rule 57 (factor -> appel_fonction_expr .)
    MINUS           reduce using rule 57 (factor -> appel_fonction_expr .)
    PLUS            reduce using rule 57 (factor -> appel_fonction_expr .)
    DIV             reduce using rule 57 (factor -> appel_fonction_expr .)
    MULT            reduce using rule 57 (factor -> appel_fonction_expr .)
    ;               reduce using rule 57 (factor -> appel_fonction_expr .)
    ET              reduce using rule 57 (factor -> appel_fonction_expr .)
    COMPARATEUR     reduce using rule 57 (factor -> appel_fonction_expr .)
    MODULO          reduce using rule 57 (factor -> appel_fonction_expr .)
    )               reduce using rule 57 (factor -> appel_fonction_expr .)
    ,               reduce using rule 57 (factor -> appel_fonction_expr .)


state 45

    (27) boucle -> TANTQUE ( . expr ) { listeInstructions }
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 71
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 46

    (23) condition -> SI ( . expr ) { listeInstructions } suite_sinosi
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 72
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 47

    (19) ecrire -> ECRIRE ( . expr ) ;
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 73
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 48

    (35) fonction_declaration_without_parm -> type IDENTIFIANT . ( ) { listeInstructions }
    (34) fonction_declaration -> type IDENTIFIANT . ( param_list ) { listeInstructions }
    (20) declaration -> type IDENTIFIANT . ;
    (21) declaration -> type IDENTIFIANT . = expr ;
    (               shift and go to state 74
    ;               shift and go to state 51
    =               shift and go to state 52


state 49

    (20) declaration -> type IDENTIFIANT . ;
    (21) declaration -> type IDENTIFIANT . = expr ;
    ;               shift and go to state 51
    =               shift and go to state 52


state 50

    (34) fonction_declaration -> type IDENTIFIANT ( . param_list ) { listeInstructions }
    (35) fonction_declaration_without_parm -> type IDENTIFIANT ( . ) { listeInstructions }
    (36) param_list -> . param_list , param
    (37) param_list -> . param
    (38) param -> . type IDENTIFIANT
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    )               shift and go to state 77
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    type                           shift and go to state 75
    param_list                     shift and go to state 76
    param                          shift and go to state 78

state 51

    (20) declaration -> type IDENTIFIANT ; .
    IDENTIFIANT     reduce using rule 20 (declaration -> type IDENTIFIANT ; .)
    RETOURNER       reduce using rule 20 (declaration -> type IDENTIFIANT ; .)
    TANTQUE         reduce using rule 20 (declaration -> type IDENTIFIANT ; .)
    SI              reduce using rule 20 (declaration -> type IDENTIFIANT ; .)
    ECRIRE          reduce using rule 20 (declaration -> type IDENTIFIANT ; .)
    ENT             reduce using rule 20 (declaration -> type IDENTIFIANT ; .)
    BOOLEEN         reduce using rule 20 (declaration -> type IDENTIFIANT ; .)
    $end            reduce using rule 20 (declaration -> type IDENTIFIANT ; .)
    }               reduce using rule 20 (declaration -> type IDENTIFIANT ; .)


state 52

    (21) declaration -> type IDENTIFIANT = . expr ;
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 79
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 53

    (32) appel_fonction_instr_without_parm -> IDENTIFIANT ( ) . ;
    ;               shift and go to state 80


state 54

    (30) appel_fonction_instr -> IDENTIFIANT ( arg_list . ) ;
    (60) arg_list -> arg_list . , expr
    )               shift and go to state 81
    ,               shift and go to state 82


state 55

    (61) arg_list -> expr .
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    )               reduce using rule 61 (arg_list -> expr .)
    ,               reduce using rule 61 (arg_list -> expr .)
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 56

    (22) affectation -> IDENTIFIANT = expr . ;
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    ;               shift and go to state 83
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 57

    (28) retourner -> RETOURNER expr ; .
    IDENTIFIANT     reduce using rule 28 (retourner -> RETOURNER expr ; .)
    RETOURNER       reduce using rule 28 (retourner -> RETOURNER expr ; .)
    TANTQUE         reduce using rule 28 (retourner -> RETOURNER expr ; .)
    SI              reduce using rule 28 (retourner -> RETOURNER expr ; .)
    ECRIRE          reduce using rule 28 (retourner -> RETOURNER expr ; .)
    ENT             reduce using rule 28 (retourner -> RETOURNER expr ; .)
    BOOLEEN         reduce using rule 28 (retourner -> RETOURNER expr ; .)
    $end            reduce using rule 28 (retourner -> RETOURNER expr ; .)
    }               reduce using rule 28 (retourner -> RETOURNER expr ; .)


state 58

    (39) expr -> expr ET . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 84
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 59

    (40) expr -> expr COMPARATEUR . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 85
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 60

    (41) expr -> expr MODULO . term
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    term                           shift and go to state 86
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 61

    (43) expr -> term MINUS . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    term                           shift and go to state 34
    expr                           shift and go to state 87
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 62

    (44) expr -> term PLUS . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    term                           shift and go to state 34
    expr                           shift and go to state 88
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 63

    (46) term -> term DIV . factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    factor                         shift and go to state 89
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 64

    (47) term -> term MULT . factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    factor                         shift and go to state 90
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 65

    (49) factor -> MINUS factor .
    (51) factor -> factor . OU expr
    MINUS           reduce using rule 49 (factor -> MINUS factor .)
    PLUS            reduce using rule 49 (factor -> MINUS factor .)
    DIV             reduce using rule 49 (factor -> MINUS factor .)
    MULT            reduce using rule 49 (factor -> MINUS factor .)
    ;               reduce using rule 49 (factor -> MINUS factor .)
    ET              reduce using rule 49 (factor -> MINUS factor .)
    COMPARATEUR     reduce using rule 49 (factor -> MINUS factor .)
    MODULO          reduce using rule 49 (factor -> MINUS factor .)
    )               reduce using rule 49 (factor -> MINUS factor .)
    ,               reduce using rule 49 (factor -> MINUS factor .)
    OU              shift and go to state 66


state 66

    (51) factor -> factor OU . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    factor                         shift and go to state 36
    expr                           shift and go to state 91
    term                           shift and go to state 34
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 67

    (48) factor -> LIRE ( . )
    )               shift and go to state 92


state 68

    (53) factor -> ( expr . )
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    )               shift and go to state 93
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 69

    (50) factor -> NON expr .
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    OU              reduce using rule 50 (factor -> NON expr .)
    MINUS           reduce using rule 50 (factor -> NON expr .)
    PLUS            reduce using rule 50 (factor -> NON expr .)
    DIV             reduce using rule 50 (factor -> NON expr .)
    MULT            reduce using rule 50 (factor -> NON expr .)
    ;               reduce using rule 50 (factor -> NON expr .)
    )               reduce using rule 50 (factor -> NON expr .)
    ,               reduce using rule 50 (factor -> NON expr .)
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 70

    (33) appel_fonction_expr_without_parm -> IDENTIFIANT ( . )
    (31) appel_fonction_expr -> IDENTIFIANT ( . arg_list )
    (60) arg_list -> . arg_list , expr
    (61) arg_list -> . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    )               shift and go to state 94
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    arg_list                       shift and go to state 95
    expr                           shift and go to state 55
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 71

    (27) boucle -> TANTQUE ( expr . ) { listeInstructions }
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    )               shift and go to state 96
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 72

    (23) condition -> SI ( expr . ) { listeInstructions } suite_sinosi
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    )               shift and go to state 97
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 73

    (19) ecrire -> ECRIRE ( expr . ) ;
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    )               shift and go to state 98
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 74

    (35) fonction_declaration_without_parm -> type IDENTIFIANT ( . ) { listeInstructions }
    (34) fonction_declaration -> type IDENTIFIANT ( . param_list ) { listeInstructions }
    (36) param_list -> . param_list , param
    (37) param_list -> . param
    (38) param -> . type IDENTIFIANT
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    )               shift and go to state 77
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    type                           shift and go to state 75
    param_list                     shift and go to state 76
    param                          shift and go to state 78

state 75

    (38) param -> type . IDENTIFIANT
    IDENTIFIANT     shift and go to state 99


state 76

    (34) fonction_declaration -> type IDENTIFIANT ( param_list . ) { listeInstructions }
    (36) param_list -> param_list . , param
    )               shift and go to state 100
    ,               shift and go to state 101


state 77

    (35) fonction_declaration_without_parm -> type IDENTIFIANT ( ) . { listeInstructions }
    {               shift and go to state 102


state 78

    (37) param_list -> param .
    )               reduce using rule 37 (param_list -> param .)
    ,               reduce using rule 37 (param_list -> param .)


state 79

    (21) declaration -> type IDENTIFIANT = expr . ;
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    ;               shift and go to state 103
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 80

    (32) appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .
    IDENTIFIANT     reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    RETOURNER       reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    TANTQUE         reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    SI              reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    ECRIRE          reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    ENT             reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    BOOLEEN         reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    $end            reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    }               reduce using rule 32 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)


state 81

    (30) appel_fonction_instr -> IDENTIFIANT ( arg_list ) . ;
    ;               shift and go to state 104


state 82

    (60) arg_list -> arg_list , . expr
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 105
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 83

    (22) affectation -> IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)
    RETOURNER       reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)
    TANTQUE         reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)
    SI              reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)
    ENT             reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)
    }               reduce using rule 22 (affectation -> IDENTIFIANT = expr ; .)


state 84

    (39) expr -> expr ET expr .
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    ;               reduce using rule 39 (expr -> expr ET expr .)
    ET              reduce using rule 39 (expr -> expr ET expr .)
    MODULO          reduce using rule 39 (expr -> expr ET expr .)
    )               reduce using rule 39 (expr -> expr ET expr .)
    ,               reduce using rule 39 (expr -> expr ET expr .)
    OU              reduce using rule 39 (expr -> expr ET expr .)
    MINUS           reduce using rule 39 (expr -> expr ET expr .)
    PLUS            reduce using rule 39 (expr -> expr ET expr .)
    DIV             reduce using rule 39 (expr -> expr ET expr .)
    MULT            reduce using rule 39 (expr -> expr ET expr .)
    COMPARATEUR     shift and go to state 59


state 85

    (40) expr -> expr COMPARATEUR expr .
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    ;               reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    ET              reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    COMPARATEUR     reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    MODULO          reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    )               reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    ,               reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    OU              reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    MINUS           reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    PLUS            reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    DIV             reduce using rule 40 (expr -> expr COMPARATEUR expr .)
    MULT            reduce using rule 40 (expr -> expr COMPARATEUR expr .)


state 86

    (41) expr -> expr MODULO term .
    (46) term -> term . DIV factor
    (47) term -> term . MULT factor
    ;               reduce using rule 41 (expr -> expr MODULO term .)
    ET              reduce using rule 41 (expr -> expr MODULO term .)
    COMPARATEUR     reduce using rule 41 (expr -> expr MODULO term .)
    MODULO          reduce using rule 41 (expr -> expr MODULO term .)
    )               reduce using rule 41 (expr -> expr MODULO term .)
    ,               reduce using rule 41 (expr -> expr MODULO term .)
    OU              reduce using rule 41 (expr -> expr MODULO term .)
    MINUS           reduce using rule 41 (expr -> expr MODULO term .)
    PLUS            reduce using rule 41 (expr -> expr MODULO term .)
    DIV             reduce using rule 41 (expr -> expr MODULO term .)
    MULT            reduce using rule 41 (expr -> expr MODULO term .)


state 87

    (43) expr -> term MINUS expr .
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    ;               reduce using rule 43 (expr -> term MINUS expr .)
    MODULO          reduce using rule 43 (expr -> term MINUS expr .)
    )               reduce using rule 43 (expr -> term MINUS expr .)
    ,               reduce using rule 43 (expr -> term MINUS expr .)
    OU              reduce using rule 43 (expr -> term MINUS expr .)
    MINUS           reduce using rule 43 (expr -> term MINUS expr .)
    PLUS            reduce using rule 43 (expr -> term MINUS expr .)
    DIV             reduce using rule 43 (expr -> term MINUS expr .)
    MULT            reduce using rule 43 (expr -> term MINUS expr .)
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59


state 88

    (44) expr -> term PLUS expr .
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    ;               reduce using rule 44 (expr -> term PLUS expr .)
    MODULO          reduce using rule 44 (expr -> term PLUS expr .)
    )               reduce using rule 44 (expr -> term PLUS expr .)
    ,               reduce using rule 44 (expr -> term PLUS expr .)
    OU              reduce using rule 44 (expr -> term PLUS expr .)
    MINUS           reduce using rule 44 (expr -> term PLUS expr .)
    PLUS            reduce using rule 44 (expr -> term PLUS expr .)
    DIV             reduce using rule 44 (expr -> term PLUS expr .)
    MULT            reduce using rule 44 (expr -> term PLUS expr .)
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59


state 89

    (46) term -> term DIV factor .
    (51) factor -> factor . OU expr
    MINUS           reduce using rule 46 (term -> term DIV factor .)
    PLUS            reduce using rule 46 (term -> term DIV factor .)
    DIV             reduce using rule 46 (term -> term DIV factor .)
    MULT            reduce using rule 46 (term -> term DIV factor .)
    ;               reduce using rule 46 (term -> term DIV factor .)
    ET              reduce using rule 46 (term -> term DIV factor .)
    COMPARATEUR     reduce using rule 46 (term -> term DIV factor .)
    MODULO          reduce using rule 46 (term -> term DIV factor .)
    )               reduce using rule 46 (term -> term DIV factor .)
    ,               reduce using rule 46 (term -> term DIV factor .)
    OU              shift and go to state 66


state 90

    (47) term -> term MULT factor .
    (51) factor -> factor . OU expr
    MINUS           reduce using rule 47 (term -> term MULT factor .)
    PLUS            reduce using rule 47 (term -> term MULT factor .)
    DIV             reduce using rule 47 (term -> term MULT factor .)
    MULT            reduce using rule 47 (term -> term MULT factor .)
    ;               reduce using rule 47 (term -> term MULT factor .)
    ET              reduce using rule 47 (term -> term MULT factor .)
    COMPARATEUR     reduce using rule 47 (term -> term MULT factor .)
    MODULO          reduce using rule 47 (term -> term MULT factor .)
    )               reduce using rule 47 (term -> term MULT factor .)
    ,               reduce using rule 47 (term -> term MULT factor .)
    OU              shift and go to state 66


state 91

    (51) factor -> factor OU expr .
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    OU              reduce using rule 51 (factor -> factor OU expr .)
    MINUS           reduce using rule 51 (factor -> factor OU expr .)
    PLUS            reduce using rule 51 (factor -> factor OU expr .)
    DIV             reduce using rule 51 (factor -> factor OU expr .)
    MULT            reduce using rule 51 (factor -> factor OU expr .)
    ;               reduce using rule 51 (factor -> factor OU expr .)
    ET              reduce using rule 51 (factor -> factor OU expr .)
    MODULO          reduce using rule 51 (factor -> factor OU expr .)
    )               reduce using rule 51 (factor -> factor OU expr .)
    ,               reduce using rule 51 (factor -> factor OU expr .)
    COMPARATEUR     shift and go to state 59


state 92

    (48) factor -> LIRE ( ) .
    OU              reduce using rule 48 (factor -> LIRE ( ) .)
    MINUS           reduce using rule 48 (factor -> LIRE ( ) .)
    PLUS            reduce using rule 48 (factor -> LIRE ( ) .)
    DIV             reduce using rule 48 (factor -> LIRE ( ) .)
    MULT            reduce using rule 48 (factor -> LIRE ( ) .)
    ;               reduce using rule 48 (factor -> LIRE ( ) .)
    ET              reduce using rule 48 (factor -> LIRE ( ) .)
    COMPARATEUR     reduce using rule 48 (factor -> LIRE ( ) .)
    MODULO          reduce using rule 48 (factor -> LIRE ( ) .)
    )               reduce using rule 48 (factor -> LIRE ( ) .)
    ,               reduce using rule 48 (factor -> LIRE ( ) .)


state 93

    (53) factor -> ( expr ) .
    OU              reduce using rule 53 (factor -> ( expr ) .)
    MINUS           reduce using rule 53 (factor -> ( expr ) .)
    PLUS            reduce using rule 53 (factor -> ( expr ) .)
    DIV             reduce using rule 53 (factor -> ( expr ) .)
    MULT            reduce using rule 53 (factor -> ( expr ) .)
    ;               reduce using rule 53 (factor -> ( expr ) .)
    ET              reduce using rule 53 (factor -> ( expr ) .)
    COMPARATEUR     reduce using rule 53 (factor -> ( expr ) .)
    MODULO          reduce using rule 53 (factor -> ( expr ) .)
    )               reduce using rule 53 (factor -> ( expr ) .)
    ,               reduce using rule 53 (factor -> ( expr ) .)


state 94

    (33) appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .
    OU              reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    MINUS           reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    PLUS            reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    DIV             reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    MULT            reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    ;               reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    ET              reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    COMPARATEUR     reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    MODULO          reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    )               reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    ,               reduce using rule 33 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)


state 95

    (31) appel_fonction_expr -> IDENTIFIANT ( arg_list . )
    (60) arg_list -> arg_list . , expr
    )               shift and go to state 106
    ,               shift and go to state 82


state 96

    (27) boucle -> TANTQUE ( expr ) . { listeInstructions }
    {               shift and go to state 107


state 97

    (23) condition -> SI ( expr ) . { listeInstructions } suite_sinosi
    {               shift and go to state 108


state 98

    (19) ecrire -> ECRIRE ( expr ) . ;
    ;               shift and go to state 109


state 99

    (38) param -> type IDENTIFIANT .
    )               reduce using rule 38 (param -> type IDENTIFIANT .)
    ,               reduce using rule 38 (param -> type IDENTIFIANT .)


state 100

    (34) fonction_declaration -> type IDENTIFIANT ( param_list ) . { listeInstructions }
    {               shift and go to state 110


state 101

    (36) param_list -> param_list , . param
    (38) param -> . type IDENTIFIANT
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    param                          shift and go to state 111
    type                           shift and go to state 75

state 102

    (35) fonction_declaration_without_parm -> type IDENTIFIANT ( ) { . listeInstructions }
    (9) listeInstructions -> . instruction
    (10) listeInstructions -> . listeInstructions instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    type                           shift and go to state 29
    listeInstructions              shift and go to state 112
    instruction                    shift and go to state 7
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17

state 103

    (21) declaration -> type IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)
    RETOURNER       reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)
    TANTQUE         reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)
    SI              reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)
    ENT             reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)
    $end            reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)
    }               reduce using rule 21 (declaration -> type IDENTIFIANT = expr ; .)


state 104

    (30) appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .
    IDENTIFIANT     reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    RETOURNER       reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    TANTQUE         reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    SI              reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    ECRIRE          reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    ENT             reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    BOOLEEN         reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    $end            reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    }               reduce using rule 30 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)


state 105

    (60) arg_list -> arg_list , expr .
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    )               reduce using rule 60 (arg_list -> arg_list , expr .)
    ,               reduce using rule 60 (arg_list -> arg_list , expr .)
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 106

    (31) appel_fonction_expr -> IDENTIFIANT ( arg_list ) .
    OU              reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    MINUS           reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    PLUS            reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    DIV             reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    MULT            reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    ;               reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    ET              reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    COMPARATEUR     reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    MODULO          reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    )               reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    ,               reduce using rule 31 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)


state 107

    (27) boucle -> TANTQUE ( expr ) { . listeInstructions }
    (9) listeInstructions -> . instruction
    (10) listeInstructions -> . listeInstructions instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    listeInstructions              shift and go to state 113
    instruction                    shift and go to state 7
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 108

    (23) condition -> SI ( expr ) { . listeInstructions } suite_sinosi
    (9) listeInstructions -> . instruction
    (10) listeInstructions -> . listeInstructions instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    listeInstructions              shift and go to state 114
    instruction                    shift and go to state 7
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 109

    (19) ecrire -> ECRIRE ( expr ) ; .
    IDENTIFIANT     reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    RETOURNER       reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    TANTQUE         reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    SI              reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    ENT             reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    BOOLEEN         reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    }               reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)


state 110

    (34) fonction_declaration -> type IDENTIFIANT ( param_list ) { . listeInstructions }
    (9) listeInstructions -> . instruction
    (10) listeInstructions -> . listeInstructions instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    type                           shift and go to state 29
    listeInstructions              shift and go to state 115
    instruction                    shift and go to state 7
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17

state 111

    (36) param_list -> param_list , param .
    )               reduce using rule 36 (param_list -> param_list , param .)
    ,               reduce using rule 36 (param_list -> param_list , param .)


state 112

    (35) fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions . }
    (10) listeInstructions -> listeInstructions . instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    }               shift and go to state 116
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    type                           shift and go to state 29
    instruction                    shift and go to state 28
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17

state 113

    (27) boucle -> TANTQUE ( expr ) { listeInstructions . }
    (10) listeInstructions -> listeInstructions . instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    }               shift and go to state 117
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    instruction                    shift and go to state 28
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 114

    (23) condition -> SI ( expr ) { listeInstructions . } suite_sinosi
    (10) listeInstructions -> listeInstructions . instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    }               shift and go to state 118
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    instruction                    shift and go to state 28
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 115

    (34) fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions . }
    (10) listeInstructions -> listeInstructions . instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    }               shift and go to state 119
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    type                           shift and go to state 29
    instruction                    shift and go to state 28
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17

state 116

    (35) fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .
    ENT             reduce using rule 35 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    BOOLEEN         reduce using rule 35 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    IDENTIFIANT     reduce using rule 35 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    RETOURNER       reduce using rule 35 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    TANTQUE         reduce using rule 35 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    SI              reduce using rule 35 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    ECRIRE          reduce using rule 35 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    $end            reduce using rule 35 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)


state 117

    (27) boucle -> TANTQUE ( expr ) { listeInstructions } .
    IDENTIFIANT     reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    RETOURNER       reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    TANTQUE         reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    SI              reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    ECRIRE          reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    ENT             reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    BOOLEEN         reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    $end            reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    }               reduce using rule 27 (boucle -> TANTQUE ( expr ) { listeInstructions } .)


state 118

    (23) condition -> SI ( expr ) { listeInstructions } . suite_sinosi
    (24) suite_sinosi -> .
    (25) suite_sinosi -> . SINON SI ( expr ) { listeInstructions } suite_sinosi
    (26) suite_sinosi -> . SINON { listeInstructions }
    IDENTIFIANT     reduce using rule 24 (suite_sinosi -> .)
    RETOURNER       reduce using rule 24 (suite_sinosi -> .)
    TANTQUE         reduce using rule 24 (suite_sinosi -> .)
    SI              reduce using rule 24 (suite_sinosi -> .)
    ECRIRE          reduce using rule 24 (suite_sinosi -> .)
    ENT             reduce using rule 24 (suite_sinosi -> .)
    BOOLEEN         reduce using rule 24 (suite_sinosi -> .)
    $end            reduce using rule 24 (suite_sinosi -> .)
    }               reduce using rule 24 (suite_sinosi -> .)
    SINON           shift and go to state 121

    suite_sinosi                   shift and go to state 120

state 119

    (34) fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .
    ENT             reduce using rule 34 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    BOOLEEN         reduce using rule 34 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    IDENTIFIANT     reduce using rule 34 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    RETOURNER       reduce using rule 34 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    TANTQUE         reduce using rule 34 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    SI              reduce using rule 34 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    ECRIRE          reduce using rule 34 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    $end            reduce using rule 34 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)


state 120

    (23) condition -> SI ( expr ) { listeInstructions } suite_sinosi .
    IDENTIFIANT     reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    RETOURNER       reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    TANTQUE         reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    SI              reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    ECRIRE          reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    ENT             reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    BOOLEEN         reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    $end            reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    }               reduce using rule 23 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)


state 121

    (25) suite_sinosi -> SINON . SI ( expr ) { listeInstructions } suite_sinosi
    (26) suite_sinosi -> SINON . { listeInstructions }
    SI              shift and go to state 122
    {               shift and go to state 123


state 122

    (25) suite_sinosi -> SINON SI . ( expr ) { listeInstructions } suite_sinosi
    (               shift and go to state 124


state 123

    (26) suite_sinosi -> SINON { . listeInstructions }
    (9) listeInstructions -> . instruction
    (10) listeInstructions -> . listeInstructions instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    listeInstructions              shift and go to state 125
    instruction                    shift and go to state 7
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 124

    (25) suite_sinosi -> SINON SI ( . expr ) { listeInstructions } suite_sinosi
    (39) expr -> . expr ET expr
    (40) expr -> . expr COMPARATEUR expr
    (41) expr -> . expr MODULO term
    (42) expr -> . term
    (43) expr -> . term MINUS expr
    (44) expr -> . term PLUS expr
    (45) term -> . factor
    (46) term -> . term DIV factor
    (47) term -> . term MULT factor
    (48) factor -> . LIRE ( )
    (49) factor -> . MINUS factor
    (50) factor -> . NON expr
    (51) factor -> . factor OU expr
    (52) factor -> . IDENTIFIANT
    (53) factor -> . ( expr )
    (54) factor -> . BOOLEEN_LITERAL
    (55) factor -> . ENTIER
    (56) factor -> . appel_fonction_expr_without_parm
    (57) factor -> . appel_fonction_expr
    (33) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (31) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 37
    MINUS           shift and go to state 35
    NON             shift and go to state 39
    IDENTIFIANT     shift and go to state 40
    (               shift and go to state 38
    BOOLEEN_LITERAL shift and go to state 41
    ENTIER          shift and go to state 42

    expr                           shift and go to state 126
    term                           shift and go to state 34
    factor                         shift and go to state 36
    appel_fonction_expr_without_parm shift and go to state 43
    appel_fonction_expr            shift and go to state 44

state 125

    (26) suite_sinosi -> SINON { listeInstructions . }
    (10) listeInstructions -> listeInstructions . instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    }               shift and go to state 127
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    instruction                    shift and go to state 28
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 126

    (25) suite_sinosi -> SINON SI ( expr . ) { listeInstructions } suite_sinosi
    (39) expr -> expr . ET expr
    (40) expr -> expr . COMPARATEUR expr
    (41) expr -> expr . MODULO term
    )               shift and go to state 128
    ET              shift and go to state 58
    COMPARATEUR     shift and go to state 59
    MODULO          shift and go to state 60


state 127

    (26) suite_sinosi -> SINON { listeInstructions } .
    IDENTIFIANT     reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)
    RETOURNER       reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)
    TANTQUE         reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)
    SI              reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)
    ECRIRE          reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)
    ENT             reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)
    BOOLEEN         reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)
    $end            reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)
    }               reduce using rule 26 (suite_sinosi -> SINON { listeInstructions } .)


state 128

    (25) suite_sinosi -> SINON SI ( expr ) . { listeInstructions } suite_sinosi
    {               shift and go to state 129


state 129

    (25) suite_sinosi -> SINON SI ( expr ) { . listeInstructions } suite_sinosi
    (9) listeInstructions -> . instruction
    (10) listeInstructions -> . listeInstructions instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    listeInstructions              shift and go to state 130
    instruction                    shift and go to state 7
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 130

    (25) suite_sinosi -> SINON SI ( expr ) { listeInstructions . } suite_sinosi
    (10) listeInstructions -> listeInstructions . instruction
    (11) instruction -> . appel_fonction_instr_without_parm
    (12) instruction -> . appel_fonction_instr
    (13) instruction -> . retourner
    (14) instruction -> . boucle
    (15) instruction -> . condition
    (16) instruction -> . affectation
    (17) instruction -> . declaration
    (18) instruction -> . ecrire
    (32) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (30) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (28) retourner -> . RETOURNER expr ;
    (29) retourner -> . retourner
    (27) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (23) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (22) affectation -> . IDENTIFIANT = expr ;
    (20) declaration -> . type IDENTIFIANT ;
    (21) declaration -> . type IDENTIFIANT = expr ;
    (19) ecrire -> . ECRIRE ( expr ) ;
    (58) type -> . ENT
    (59) type -> . BOOLEEN
    }               shift and go to state 131
    IDENTIFIANT     shift and go to state 9
    RETOURNER       shift and go to state 20
    TANTQUE         shift and go to state 21
    SI              shift and go to state 22
    ECRIRE          shift and go to state 23
    ENT             shift and go to state 18
    BOOLEEN         shift and go to state 19

    instruction                    shift and go to state 28
    appel_fonction_instr_without_parm shift and go to state 10
    appel_fonction_instr           shift and go to state 11
    retourner                      shift and go to state 12
    boucle                         shift and go to state 13
    condition                      shift and go to state 14
    affectation                    shift and go to state 15
    declaration                    shift and go to state 16
    ecrire                         shift and go to state 17
    type                           shift and go to state 29

state 131

    (25) suite_sinosi -> SINON SI ( expr ) { listeInstructions } . suite_sinosi
    (24) suite_sinosi -> .
    (25) suite_sinosi -> . SINON SI ( expr ) { listeInstructions } suite_sinosi
    (26) suite_sinosi -> . SINON { listeInstructions }
    IDENTIFIANT     reduce using rule 24 (suite_sinosi -> .)
    RETOURNER       reduce using rule 24 (suite_sinosi -> .)
    TANTQUE         reduce using rule 24 (suite_sinosi -> .)
    SI              reduce using rule 24 (suite_sinosi -> .)
    ECRIRE          reduce using rule 24 (suite_sinosi -> .)
    ENT             reduce using rule 24 (suite_sinosi -> .)
    BOOLEEN         reduce using rule 24 (suite_sinosi -> .)
    $end            reduce using rule 24 (suite_sinosi -> .)
    }               reduce using rule 24 (suite_sinosi -> .)
    SINON           shift and go to state 121

    suite_sinosi                   shift and go to state 132

state 132

    (25) suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .
    IDENTIFIANT     reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    RETOURNER       reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    TANTQUE         reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    SI              reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    ECRIRE          reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    ENT             reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    BOOLEEN         reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    $end            reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    }               reduce using rule 25 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)


Conflicts:

shift/reduce conflict for MINUS in state 34 resolved as shift
shift/reduce conflict for PLUS in state 34 resolved as shift
shift/reduce conflict for DIV in state 34 resolved as shift
shift/reduce conflict for MULT in state 34 resolved as shift
shift/reduce conflict for OU in state 36 resolved as shift
reduce/reduce conflict in state 12 resolved using rule instruction -> retourner
rejected rule (retourner -> retourner) in state 12
Rule (retourner -> retourner) is never reduced