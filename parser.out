Grammar:

Rule 0     S' -> statement
Rule 1     statement -> prog
Rule 2     prog -> listeInstructions
Rule 3     listeInstructions -> instruction
Rule 4     listeInstructions -> listeInstructions instruction
Rule 5     instruction -> fonction_declaration
Rule 6     instruction -> fonction_declaration_without_parm
Rule 7     instruction -> appel_fonction_instr_without_parm
Rule 8     instruction -> appel_fonction_instr
Rule 9     instruction -> retourner
Rule 10    instruction -> boucle
Rule 11    instruction -> condition
Rule 12    instruction -> affectation
Rule 13    instruction -> declaration
Rule 14    instruction -> ecrire
Rule 15    ecrire -> ECRIRE ( expr ) ;
Rule 16    declaration -> type IDENTIFIANT = expr ;
Rule 17    affectation -> IDENTIFIANT = expr ;
Rule 18    condition -> SI ( expr ) { listeInstructions } suite_sinosi
Rule 19    suite_sinosi -> <empty>
Rule 20    suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi
Rule 21    suite_sinosi -> SINON { listeInstructions }
Rule 22    boucle -> TANTQUE ( expr ) { listeInstructions }
Rule 23    retourner -> RETOURNER expr ;
Rule 24    retourner -> retourner
Rule 25    appel_fonction_instr -> IDENTIFIANT ( arg_list ) ;
Rule 26    appel_fonction_expr -> IDENTIFIANT ( arg_list )
Rule 27    appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ;
Rule 28    appel_fonction_expr_without_parm -> IDENTIFIANT ( )
Rule 29    fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions }
Rule 30    fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions }
Rule 31    param_list -> param_list , param
Rule 32    param_list -> param
Rule 33    param -> type IDENTIFIANT
Rule 34    expr -> expr ET expr  [precedence=left, level=5]
Rule 35    expr -> expr DIV term  [precedence=left, level=3]
Rule 36    expr -> expr COMPARATEUR expr  [precedence=nonassoc, level=7]
Rule 37    expr -> expr MODULO term  [precedence=left, level=3]
Rule 38    expr -> term
Rule 39    term -> term MINUS factor  [precedence=left, level=4]
Rule 40    term -> term PLUS factor  [precedence=left, level=4]
Rule 41    term -> factor
Rule 42    term -> term MULT factor  [precedence=left, level=3]
Rule 43    term -> appel_fonction_expr_without_parm
Rule 44    term -> appel_fonction_expr
Rule 45    factor -> LIRE ( )
Rule 46    factor -> MINUS factor  [precedence=nonassoc, level=2]
Rule 47    factor -> NON expr  [precedence=nonassoc, level=1]
Rule 48    factor -> factor OU expr  [precedence=left, level=6]
Rule 49    factor -> IDENTIFIANT
Rule 50    factor -> ( expr )
Rule 51    factor -> BOOLEEN_LITERAL
Rule 52    factor -> ENTIER
Rule 53    type -> ENT
Rule 54    type -> BOOLEEN
Rule 55    arg_list -> arg_list , expr
Rule 56    arg_list -> expr

Unused terminals:

    UMINUS
    ALORS

Terminals, with rules where they appear:

(                    : 15 18 20 22 25 26 27 28 29 30 45 50
)                    : 15 18 20 22 25 26 27 28 29 30 45 50
,                    : 31 55
;                    : 15 16 17 23 25 27
=                    : 16 17
ALORS                : 
BOOLEEN              : 54
BOOLEEN_LITERAL      : 51
COMPARATEUR          : 36
DIV                  : 35
ECRIRE               : 15
ENT                  : 53
ENTIER               : 52
ET                   : 34
IDENTIFIANT          : 16 17 25 26 27 28 29 30 33 49
LIRE                 : 45
MINUS                : 39 46
MODULO               : 37
MULT                 : 42
NON                  : 47
OU                   : 48
PLUS                 : 40
RETOURNER            : 23
SI                   : 18 20
SINON                : 20 21
TANTQUE              : 22
UMINUS               : 
error                : 
{                    : 18 20 21 22 29 30
}                    : 18 20 21 22 29 30

Nonterminals, with rules where they appear:

affectation          : 12
appel_fonction_expr  : 44
appel_fonction_expr_without_parm : 43
appel_fonction_instr : 8
appel_fonction_instr_without_parm : 7
arg_list             : 25 26 55
boucle               : 10
condition            : 11
declaration          : 13
ecrire               : 14
expr                 : 15 16 17 18 20 22 23 34 34 35 36 36 37 47 48 50 55 56
factor               : 39 40 41 42 46 48
fonction_declaration : 5
fonction_declaration_without_parm : 6
instruction          : 3 4
listeInstructions    : 2 4 18 20 21 22 29 30
param                : 31 32
param_list           : 29 31
prog                 : 1
retourner            : 9 24
statement            : 0
suite_sinosi         : 18 20
term                 : 35 37 38 39 40 42
type                 : 16 29 30 33


state 0

    (0) S' -> . statement
    (1) statement -> . prog
    (2) prog -> . listeInstructions
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    statement                      shift and go to state 1
    prog                           shift and go to state 2
    listeInstructions              shift and go to state 3
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 1

    (0) S' -> statement .


state 2

    (1) statement -> prog .
    $end            reduce using rule 1 (statement -> prog .)


state 3

    (2) prog -> listeInstructions .
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    $end            reduce using rule 2 (prog -> listeInstructions .)
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    instruction                    shift and go to state 23
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 4

    (3) listeInstructions -> instruction .
    IDENTIFIANT     reduce using rule 3 (listeInstructions -> instruction .)
    RETOURNER       reduce using rule 3 (listeInstructions -> instruction .)
    TANTQUE         reduce using rule 3 (listeInstructions -> instruction .)
    SI              reduce using rule 3 (listeInstructions -> instruction .)
    ECRIRE          reduce using rule 3 (listeInstructions -> instruction .)
    ENT             reduce using rule 3 (listeInstructions -> instruction .)
    BOOLEEN         reduce using rule 3 (listeInstructions -> instruction .)
    $end            reduce using rule 3 (listeInstructions -> instruction .)
    }               reduce using rule 3 (listeInstructions -> instruction .)


state 5

    (5) instruction -> fonction_declaration .
    IDENTIFIANT     reduce using rule 5 (instruction -> fonction_declaration .)
    RETOURNER       reduce using rule 5 (instruction -> fonction_declaration .)
    TANTQUE         reduce using rule 5 (instruction -> fonction_declaration .)
    SI              reduce using rule 5 (instruction -> fonction_declaration .)
    ECRIRE          reduce using rule 5 (instruction -> fonction_declaration .)
    ENT             reduce using rule 5 (instruction -> fonction_declaration .)
    BOOLEEN         reduce using rule 5 (instruction -> fonction_declaration .)
    $end            reduce using rule 5 (instruction -> fonction_declaration .)
    }               reduce using rule 5 (instruction -> fonction_declaration .)


state 6

    (6) instruction -> fonction_declaration_without_parm .
    IDENTIFIANT     reduce using rule 6 (instruction -> fonction_declaration_without_parm .)
    RETOURNER       reduce using rule 6 (instruction -> fonction_declaration_without_parm .)
    TANTQUE         reduce using rule 6 (instruction -> fonction_declaration_without_parm .)
    SI              reduce using rule 6 (instruction -> fonction_declaration_without_parm .)
    ECRIRE          reduce using rule 6 (instruction -> fonction_declaration_without_parm .)
    ENT             reduce using rule 6 (instruction -> fonction_declaration_without_parm .)
    BOOLEEN         reduce using rule 6 (instruction -> fonction_declaration_without_parm .)
    $end            reduce using rule 6 (instruction -> fonction_declaration_without_parm .)
    }               reduce using rule 6 (instruction -> fonction_declaration_without_parm .)


state 7

    (7) instruction -> appel_fonction_instr_without_parm .
    IDENTIFIANT     reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)
    RETOURNER       reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)
    TANTQUE         reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)
    SI              reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)
    ECRIRE          reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)
    ENT             reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)
    BOOLEEN         reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)
    $end            reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)
    }               reduce using rule 7 (instruction -> appel_fonction_instr_without_parm .)


state 8

    (8) instruction -> appel_fonction_instr .
    IDENTIFIANT     reduce using rule 8 (instruction -> appel_fonction_instr .)
    RETOURNER       reduce using rule 8 (instruction -> appel_fonction_instr .)
    TANTQUE         reduce using rule 8 (instruction -> appel_fonction_instr .)
    SI              reduce using rule 8 (instruction -> appel_fonction_instr .)
    ECRIRE          reduce using rule 8 (instruction -> appel_fonction_instr .)
    ENT             reduce using rule 8 (instruction -> appel_fonction_instr .)
    BOOLEEN         reduce using rule 8 (instruction -> appel_fonction_instr .)
    $end            reduce using rule 8 (instruction -> appel_fonction_instr .)
    }               reduce using rule 8 (instruction -> appel_fonction_instr .)


state 9

    (9) instruction -> retourner .
    (24) retourner -> retourner .
  ! reduce/reduce conflict for IDENTIFIANT resolved using rule 9 (instruction -> retourner .)
  ! reduce/reduce conflict for RETOURNER resolved using rule 9 (instruction -> retourner .)
  ! reduce/reduce conflict for TANTQUE resolved using rule 9 (instruction -> retourner .)
  ! reduce/reduce conflict for SI resolved using rule 9 (instruction -> retourner .)
  ! reduce/reduce conflict for ECRIRE resolved using rule 9 (instruction -> retourner .)
  ! reduce/reduce conflict for ENT resolved using rule 9 (instruction -> retourner .)
  ! reduce/reduce conflict for BOOLEEN resolved using rule 9 (instruction -> retourner .)
  ! reduce/reduce conflict for $end resolved using rule 9 (instruction -> retourner .)
  ! reduce/reduce conflict for } resolved using rule 9 (instruction -> retourner .)
    IDENTIFIANT     reduce using rule 9 (instruction -> retourner .)
    RETOURNER       reduce using rule 9 (instruction -> retourner .)
    TANTQUE         reduce using rule 9 (instruction -> retourner .)
    SI              reduce using rule 9 (instruction -> retourner .)
    ECRIRE          reduce using rule 9 (instruction -> retourner .)
    ENT             reduce using rule 9 (instruction -> retourner .)
    BOOLEEN         reduce using rule 9 (instruction -> retourner .)
    $end            reduce using rule 9 (instruction -> retourner .)
    }               reduce using rule 9 (instruction -> retourner .)


state 10

    (10) instruction -> boucle .
    IDENTIFIANT     reduce using rule 10 (instruction -> boucle .)
    RETOURNER       reduce using rule 10 (instruction -> boucle .)
    TANTQUE         reduce using rule 10 (instruction -> boucle .)
    SI              reduce using rule 10 (instruction -> boucle .)
    ECRIRE          reduce using rule 10 (instruction -> boucle .)
    ENT             reduce using rule 10 (instruction -> boucle .)
    BOOLEEN         reduce using rule 10 (instruction -> boucle .)
    $end            reduce using rule 10 (instruction -> boucle .)
    }               reduce using rule 10 (instruction -> boucle .)


state 11

    (11) instruction -> condition .
    IDENTIFIANT     reduce using rule 11 (instruction -> condition .)
    RETOURNER       reduce using rule 11 (instruction -> condition .)
    TANTQUE         reduce using rule 11 (instruction -> condition .)
    SI              reduce using rule 11 (instruction -> condition .)
    ECRIRE          reduce using rule 11 (instruction -> condition .)
    ENT             reduce using rule 11 (instruction -> condition .)
    BOOLEEN         reduce using rule 11 (instruction -> condition .)
    $end            reduce using rule 11 (instruction -> condition .)
    }               reduce using rule 11 (instruction -> condition .)


state 12

    (12) instruction -> affectation .
    IDENTIFIANT     reduce using rule 12 (instruction -> affectation .)
    RETOURNER       reduce using rule 12 (instruction -> affectation .)
    TANTQUE         reduce using rule 12 (instruction -> affectation .)
    SI              reduce using rule 12 (instruction -> affectation .)
    ECRIRE          reduce using rule 12 (instruction -> affectation .)
    ENT             reduce using rule 12 (instruction -> affectation .)
    BOOLEEN         reduce using rule 12 (instruction -> affectation .)
    $end            reduce using rule 12 (instruction -> affectation .)
    }               reduce using rule 12 (instruction -> affectation .)


state 13

    (13) instruction -> declaration .
    IDENTIFIANT     reduce using rule 13 (instruction -> declaration .)
    RETOURNER       reduce using rule 13 (instruction -> declaration .)
    TANTQUE         reduce using rule 13 (instruction -> declaration .)
    SI              reduce using rule 13 (instruction -> declaration .)
    ECRIRE          reduce using rule 13 (instruction -> declaration .)
    ENT             reduce using rule 13 (instruction -> declaration .)
    BOOLEEN         reduce using rule 13 (instruction -> declaration .)
    $end            reduce using rule 13 (instruction -> declaration .)
    }               reduce using rule 13 (instruction -> declaration .)


state 14

    (14) instruction -> ecrire .
    IDENTIFIANT     reduce using rule 14 (instruction -> ecrire .)
    RETOURNER       reduce using rule 14 (instruction -> ecrire .)
    TANTQUE         reduce using rule 14 (instruction -> ecrire .)
    SI              reduce using rule 14 (instruction -> ecrire .)
    ECRIRE          reduce using rule 14 (instruction -> ecrire .)
    ENT             reduce using rule 14 (instruction -> ecrire .)
    BOOLEEN         reduce using rule 14 (instruction -> ecrire .)
    $end            reduce using rule 14 (instruction -> ecrire .)
    }               reduce using rule 14 (instruction -> ecrire .)


state 15

    (29) fonction_declaration -> type . IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> type . IDENTIFIANT ( ) { listeInstructions }
    (16) declaration -> type . IDENTIFIANT = expr ;
    IDENTIFIANT     shift and go to state 24


state 16

    (27) appel_fonction_instr_without_parm -> IDENTIFIANT . ( ) ;
    (25) appel_fonction_instr -> IDENTIFIANT . ( arg_list ) ;
    (17) affectation -> IDENTIFIANT . = expr ;
    (               shift and go to state 25
    =               shift and go to state 26


state 17

    (23) retourner -> RETOURNER . expr ;
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 27
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 18

    (22) boucle -> TANTQUE . ( expr ) { listeInstructions }
    (               shift and go to state 39


state 19

    (18) condition -> SI . ( expr ) { listeInstructions } suite_sinosi
    (               shift and go to state 40


state 20

    (15) ecrire -> ECRIRE . ( expr ) ;
    (               shift and go to state 41


state 21

    (53) type -> ENT .
    IDENTIFIANT     reduce using rule 53 (type -> ENT .)


state 22

    (54) type -> BOOLEEN .
    IDENTIFIANT     reduce using rule 54 (type -> BOOLEEN .)


state 23

    (4) listeInstructions -> listeInstructions instruction .
    IDENTIFIANT     reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    RETOURNER       reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    TANTQUE         reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    SI              reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    ECRIRE          reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    ENT             reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    BOOLEEN         reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    $end            reduce using rule 4 (listeInstructions -> listeInstructions instruction .)
    }               reduce using rule 4 (listeInstructions -> listeInstructions instruction .)


state 24

    (29) fonction_declaration -> type IDENTIFIANT . ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> type IDENTIFIANT . ( ) { listeInstructions }
    (16) declaration -> type IDENTIFIANT . = expr ;
    (               shift and go to state 42
    =               shift and go to state 43


state 25

    (27) appel_fonction_instr_without_parm -> IDENTIFIANT ( . ) ;
    (25) appel_fonction_instr -> IDENTIFIANT ( . arg_list ) ;
    (55) arg_list -> . arg_list , expr
    (56) arg_list -> . expr
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    )               shift and go to state 44
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    arg_list                       shift and go to state 45
    expr                           shift and go to state 46
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 26

    (17) affectation -> IDENTIFIANT = . expr ;
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 47
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 27

    (23) retourner -> RETOURNER expr . ;
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    ;               shift and go to state 48
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 28

    (38) expr -> term .
    (39) term -> term . MINUS factor
    (40) term -> term . PLUS factor
    (42) term -> term . MULT factor
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
    ;               reduce using rule 38 (expr -> term .)
    ET              reduce using rule 38 (expr -> term .)
    DIV             reduce using rule 38 (expr -> term .)
    COMPARATEUR     reduce using rule 38 (expr -> term .)
    MODULO          reduce using rule 38 (expr -> term .)
    )               reduce using rule 38 (expr -> term .)
    ,               reduce using rule 38 (expr -> term .)
    OU              reduce using rule 38 (expr -> term .)
    MINUS           shift and go to state 53
    PLUS            shift and go to state 54
    MULT            shift and go to state 55


state 29

    (46) factor -> MINUS . factor
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 57
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    factor                         shift and go to state 56

state 30

    (41) term -> factor .
    (48) factor -> factor . OU expr
  ! shift/reduce conflict for OU resolved as shift
    MINUS           reduce using rule 41 (term -> factor .)
    PLUS            reduce using rule 41 (term -> factor .)
    MULT            reduce using rule 41 (term -> factor .)
    ;               reduce using rule 41 (term -> factor .)
    ET              reduce using rule 41 (term -> factor .)
    DIV             reduce using rule 41 (term -> factor .)
    COMPARATEUR     reduce using rule 41 (term -> factor .)
    MODULO          reduce using rule 41 (term -> factor .)
    )               reduce using rule 41 (term -> factor .)
    ,               reduce using rule 41 (term -> factor .)
    OU              shift and go to state 58


state 31

    (43) term -> appel_fonction_expr_without_parm .
    MINUS           reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    PLUS            reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    MULT            reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    ;               reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    ET              reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    DIV             reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    COMPARATEUR     reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    MODULO          reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    )               reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    ,               reduce using rule 43 (term -> appel_fonction_expr_without_parm .)
    OU              reduce using rule 43 (term -> appel_fonction_expr_without_parm .)


state 32

    (44) term -> appel_fonction_expr .
    MINUS           reduce using rule 44 (term -> appel_fonction_expr .)
    PLUS            reduce using rule 44 (term -> appel_fonction_expr .)
    MULT            reduce using rule 44 (term -> appel_fonction_expr .)
    ;               reduce using rule 44 (term -> appel_fonction_expr .)
    ET              reduce using rule 44 (term -> appel_fonction_expr .)
    DIV             reduce using rule 44 (term -> appel_fonction_expr .)
    COMPARATEUR     reduce using rule 44 (term -> appel_fonction_expr .)
    MODULO          reduce using rule 44 (term -> appel_fonction_expr .)
    )               reduce using rule 44 (term -> appel_fonction_expr .)
    ,               reduce using rule 44 (term -> appel_fonction_expr .)
    OU              reduce using rule 44 (term -> appel_fonction_expr .)


state 33

    (45) factor -> LIRE . ( )
    (               shift and go to state 59


state 34

    (50) factor -> ( . expr )
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 60
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 35

    (47) factor -> NON . expr
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 61
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 36

    (49) factor -> IDENTIFIANT .
    (28) appel_fonction_expr_without_parm -> IDENTIFIANT . ( )
    (26) appel_fonction_expr -> IDENTIFIANT . ( arg_list )
    OU              reduce using rule 49 (factor -> IDENTIFIANT .)
    MINUS           reduce using rule 49 (factor -> IDENTIFIANT .)
    PLUS            reduce using rule 49 (factor -> IDENTIFIANT .)
    MULT            reduce using rule 49 (factor -> IDENTIFIANT .)
    ;               reduce using rule 49 (factor -> IDENTIFIANT .)
    ET              reduce using rule 49 (factor -> IDENTIFIANT .)
    DIV             reduce using rule 49 (factor -> IDENTIFIANT .)
    COMPARATEUR     reduce using rule 49 (factor -> IDENTIFIANT .)
    MODULO          reduce using rule 49 (factor -> IDENTIFIANT .)
    )               reduce using rule 49 (factor -> IDENTIFIANT .)
    ,               reduce using rule 49 (factor -> IDENTIFIANT .)
    (               shift and go to state 62


state 37

    (51) factor -> BOOLEEN_LITERAL .
    OU              reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    MINUS           reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    PLUS            reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    MULT            reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    ;               reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    ET              reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    DIV             reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    COMPARATEUR     reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    MODULO          reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    )               reduce using rule 51 (factor -> BOOLEEN_LITERAL .)
    ,               reduce using rule 51 (factor -> BOOLEEN_LITERAL .)


state 38

    (52) factor -> ENTIER .
    OU              reduce using rule 52 (factor -> ENTIER .)
    MINUS           reduce using rule 52 (factor -> ENTIER .)
    PLUS            reduce using rule 52 (factor -> ENTIER .)
    MULT            reduce using rule 52 (factor -> ENTIER .)
    ;               reduce using rule 52 (factor -> ENTIER .)
    ET              reduce using rule 52 (factor -> ENTIER .)
    DIV             reduce using rule 52 (factor -> ENTIER .)
    COMPARATEUR     reduce using rule 52 (factor -> ENTIER .)
    MODULO          reduce using rule 52 (factor -> ENTIER .)
    )               reduce using rule 52 (factor -> ENTIER .)
    ,               reduce using rule 52 (factor -> ENTIER .)


state 39

    (22) boucle -> TANTQUE ( . expr ) { listeInstructions }
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 63
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 40

    (18) condition -> SI ( . expr ) { listeInstructions } suite_sinosi
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 64
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 41

    (15) ecrire -> ECRIRE ( . expr ) ;
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 65
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 42

    (29) fonction_declaration -> type IDENTIFIANT ( . param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> type IDENTIFIANT ( . ) { listeInstructions }
    (31) param_list -> . param_list , param
    (32) param_list -> . param
    (33) param -> . type IDENTIFIANT
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    )               shift and go to state 68
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    type                           shift and go to state 66
    param_list                     shift and go to state 67
    param                          shift and go to state 69

state 43

    (16) declaration -> type IDENTIFIANT = . expr ;
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 70
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 44

    (27) appel_fonction_instr_without_parm -> IDENTIFIANT ( ) . ;
    ;               shift and go to state 71


state 45

    (25) appel_fonction_instr -> IDENTIFIANT ( arg_list . ) ;
    (55) arg_list -> arg_list . , expr
    )               shift and go to state 72
    ,               shift and go to state 73


state 46

    (56) arg_list -> expr .
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    )               reduce using rule 56 (arg_list -> expr .)
    ,               reduce using rule 56 (arg_list -> expr .)
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 47

    (17) affectation -> IDENTIFIANT = expr . ;
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    ;               shift and go to state 74
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 48

    (23) retourner -> RETOURNER expr ; .
    IDENTIFIANT     reduce using rule 23 (retourner -> RETOURNER expr ; .)
    RETOURNER       reduce using rule 23 (retourner -> RETOURNER expr ; .)
    TANTQUE         reduce using rule 23 (retourner -> RETOURNER expr ; .)
    SI              reduce using rule 23 (retourner -> RETOURNER expr ; .)
    ECRIRE          reduce using rule 23 (retourner -> RETOURNER expr ; .)
    ENT             reduce using rule 23 (retourner -> RETOURNER expr ; .)
    BOOLEEN         reduce using rule 23 (retourner -> RETOURNER expr ; .)
    $end            reduce using rule 23 (retourner -> RETOURNER expr ; .)
    }               reduce using rule 23 (retourner -> RETOURNER expr ; .)


state 49

    (34) expr -> expr ET . expr
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 75
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 50

    (35) expr -> expr DIV . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    term                           shift and go to state 76
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 51

    (36) expr -> expr COMPARATEUR . expr
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 77
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 52

    (37) expr -> expr MODULO . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    term                           shift and go to state 78
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 53

    (39) term -> term MINUS . factor
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 57
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    factor                         shift and go to state 79

state 54

    (40) term -> term PLUS . factor
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 57
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    factor                         shift and go to state 80

state 55

    (42) term -> term MULT . factor
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 57
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    factor                         shift and go to state 81

state 56

    (46) factor -> MINUS factor .
    (48) factor -> factor . OU expr
    MINUS           reduce using rule 46 (factor -> MINUS factor .)
    PLUS            reduce using rule 46 (factor -> MINUS factor .)
    MULT            reduce using rule 46 (factor -> MINUS factor .)
    ;               reduce using rule 46 (factor -> MINUS factor .)
    ET              reduce using rule 46 (factor -> MINUS factor .)
    DIV             reduce using rule 46 (factor -> MINUS factor .)
    COMPARATEUR     reduce using rule 46 (factor -> MINUS factor .)
    MODULO          reduce using rule 46 (factor -> MINUS factor .)
    )               reduce using rule 46 (factor -> MINUS factor .)
    ,               reduce using rule 46 (factor -> MINUS factor .)
    OU              shift and go to state 58


state 57

    (49) factor -> IDENTIFIANT .
    OU              reduce using rule 49 (factor -> IDENTIFIANT .)
    MINUS           reduce using rule 49 (factor -> IDENTIFIANT .)
    PLUS            reduce using rule 49 (factor -> IDENTIFIANT .)
    MULT            reduce using rule 49 (factor -> IDENTIFIANT .)
    ;               reduce using rule 49 (factor -> IDENTIFIANT .)
    ET              reduce using rule 49 (factor -> IDENTIFIANT .)
    DIV             reduce using rule 49 (factor -> IDENTIFIANT .)
    COMPARATEUR     reduce using rule 49 (factor -> IDENTIFIANT .)
    MODULO          reduce using rule 49 (factor -> IDENTIFIANT .)
    )               reduce using rule 49 (factor -> IDENTIFIANT .)
    ,               reduce using rule 49 (factor -> IDENTIFIANT .)


state 58

    (48) factor -> factor OU . expr
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    factor                         shift and go to state 30
    expr                           shift and go to state 82
    term                           shift and go to state 28
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 59

    (45) factor -> LIRE ( . )
    )               shift and go to state 83


state 60

    (50) factor -> ( expr . )
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    )               shift and go to state 84
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 61

    (47) factor -> NON expr .
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    OU              reduce using rule 47 (factor -> NON expr .)
    MINUS           reduce using rule 47 (factor -> NON expr .)
    PLUS            reduce using rule 47 (factor -> NON expr .)
    MULT            reduce using rule 47 (factor -> NON expr .)
    ;               reduce using rule 47 (factor -> NON expr .)
    )               reduce using rule 47 (factor -> NON expr .)
    ,               reduce using rule 47 (factor -> NON expr .)
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 62

    (28) appel_fonction_expr_without_parm -> IDENTIFIANT ( . )
    (26) appel_fonction_expr -> IDENTIFIANT ( . arg_list )
    (55) arg_list -> . arg_list , expr
    (56) arg_list -> . expr
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    )               shift and go to state 85
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    arg_list                       shift and go to state 86
    expr                           shift and go to state 46
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 63

    (22) boucle -> TANTQUE ( expr . ) { listeInstructions }
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    )               shift and go to state 87
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 64

    (18) condition -> SI ( expr . ) { listeInstructions } suite_sinosi
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    )               shift and go to state 88
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 65

    (15) ecrire -> ECRIRE ( expr . ) ;
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    )               shift and go to state 89
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 66

    (33) param -> type . IDENTIFIANT
    IDENTIFIANT     shift and go to state 90


state 67

    (29) fonction_declaration -> type IDENTIFIANT ( param_list . ) { listeInstructions }
    (31) param_list -> param_list . , param
    )               shift and go to state 91
    ,               shift and go to state 92


state 68

    (30) fonction_declaration_without_parm -> type IDENTIFIANT ( ) . { listeInstructions }
    {               shift and go to state 93


state 69

    (32) param_list -> param .
    )               reduce using rule 32 (param_list -> param .)
    ,               reduce using rule 32 (param_list -> param .)


state 70

    (16) declaration -> type IDENTIFIANT = expr . ;
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    ;               shift and go to state 94
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 71

    (27) appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .
    IDENTIFIANT     reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    RETOURNER       reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    TANTQUE         reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    SI              reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    ECRIRE          reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    ENT             reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    BOOLEEN         reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    $end            reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)
    }               reduce using rule 27 (appel_fonction_instr_without_parm -> IDENTIFIANT ( ) ; .)


state 72

    (25) appel_fonction_instr -> IDENTIFIANT ( arg_list ) . ;
    ;               shift and go to state 95


state 73

    (55) arg_list -> arg_list , . expr
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 96
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 74

    (17) affectation -> IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)
    RETOURNER       reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)
    TANTQUE         reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)
    SI              reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)
    ENT             reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)
    }               reduce using rule 17 (affectation -> IDENTIFIANT = expr ; .)


state 75

    (34) expr -> expr ET expr .
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    ;               reduce using rule 34 (expr -> expr ET expr .)
    ET              reduce using rule 34 (expr -> expr ET expr .)
    DIV             reduce using rule 34 (expr -> expr ET expr .)
    MODULO          reduce using rule 34 (expr -> expr ET expr .)
    )               reduce using rule 34 (expr -> expr ET expr .)
    ,               reduce using rule 34 (expr -> expr ET expr .)
    OU              reduce using rule 34 (expr -> expr ET expr .)
    MINUS           reduce using rule 34 (expr -> expr ET expr .)
    PLUS            reduce using rule 34 (expr -> expr ET expr .)
    MULT            reduce using rule 34 (expr -> expr ET expr .)
    COMPARATEUR     shift and go to state 51


state 76

    (35) expr -> expr DIV term .
    (39) term -> term . MINUS factor
    (40) term -> term . PLUS factor
    (42) term -> term . MULT factor
    ;               reduce using rule 35 (expr -> expr DIV term .)
    ET              reduce using rule 35 (expr -> expr DIV term .)
    DIV             reduce using rule 35 (expr -> expr DIV term .)
    COMPARATEUR     reduce using rule 35 (expr -> expr DIV term .)
    MODULO          reduce using rule 35 (expr -> expr DIV term .)
    )               reduce using rule 35 (expr -> expr DIV term .)
    ,               reduce using rule 35 (expr -> expr DIV term .)
    OU              reduce using rule 35 (expr -> expr DIV term .)
    MULT            reduce using rule 35 (expr -> expr DIV term .)
    MINUS           shift and go to state 53
    PLUS            shift and go to state 54


state 77

    (36) expr -> expr COMPARATEUR expr .
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    ;               reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    ET              reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    DIV             reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    COMPARATEUR     reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    MODULO          reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    )               reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    ,               reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    OU              reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    MINUS           reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    PLUS            reduce using rule 36 (expr -> expr COMPARATEUR expr .)
    MULT            reduce using rule 36 (expr -> expr COMPARATEUR expr .)


state 78

    (37) expr -> expr MODULO term .
    (39) term -> term . MINUS factor
    (40) term -> term . PLUS factor
    (42) term -> term . MULT factor
    ;               reduce using rule 37 (expr -> expr MODULO term .)
    ET              reduce using rule 37 (expr -> expr MODULO term .)
    DIV             reduce using rule 37 (expr -> expr MODULO term .)
    COMPARATEUR     reduce using rule 37 (expr -> expr MODULO term .)
    MODULO          reduce using rule 37 (expr -> expr MODULO term .)
    )               reduce using rule 37 (expr -> expr MODULO term .)
    ,               reduce using rule 37 (expr -> expr MODULO term .)
    OU              reduce using rule 37 (expr -> expr MODULO term .)
    MULT            reduce using rule 37 (expr -> expr MODULO term .)
    MINUS           shift and go to state 53
    PLUS            shift and go to state 54


state 79

    (39) term -> term MINUS factor .
    (48) factor -> factor . OU expr
    MINUS           reduce using rule 39 (term -> term MINUS factor .)
    PLUS            reduce using rule 39 (term -> term MINUS factor .)
    MULT            reduce using rule 39 (term -> term MINUS factor .)
    ;               reduce using rule 39 (term -> term MINUS factor .)
    ET              reduce using rule 39 (term -> term MINUS factor .)
    DIV             reduce using rule 39 (term -> term MINUS factor .)
    COMPARATEUR     reduce using rule 39 (term -> term MINUS factor .)
    MODULO          reduce using rule 39 (term -> term MINUS factor .)
    )               reduce using rule 39 (term -> term MINUS factor .)
    ,               reduce using rule 39 (term -> term MINUS factor .)
    OU              shift and go to state 58


state 80

    (40) term -> term PLUS factor .
    (48) factor -> factor . OU expr
    MINUS           reduce using rule 40 (term -> term PLUS factor .)
    PLUS            reduce using rule 40 (term -> term PLUS factor .)
    MULT            reduce using rule 40 (term -> term PLUS factor .)
    ;               reduce using rule 40 (term -> term PLUS factor .)
    ET              reduce using rule 40 (term -> term PLUS factor .)
    DIV             reduce using rule 40 (term -> term PLUS factor .)
    COMPARATEUR     reduce using rule 40 (term -> term PLUS factor .)
    MODULO          reduce using rule 40 (term -> term PLUS factor .)
    )               reduce using rule 40 (term -> term PLUS factor .)
    ,               reduce using rule 40 (term -> term PLUS factor .)
    OU              shift and go to state 58


state 81

    (42) term -> term MULT factor .
    (48) factor -> factor . OU expr
    MINUS           reduce using rule 42 (term -> term MULT factor .)
    PLUS            reduce using rule 42 (term -> term MULT factor .)
    MULT            reduce using rule 42 (term -> term MULT factor .)
    ;               reduce using rule 42 (term -> term MULT factor .)
    ET              reduce using rule 42 (term -> term MULT factor .)
    DIV             reduce using rule 42 (term -> term MULT factor .)
    COMPARATEUR     reduce using rule 42 (term -> term MULT factor .)
    MODULO          reduce using rule 42 (term -> term MULT factor .)
    )               reduce using rule 42 (term -> term MULT factor .)
    ,               reduce using rule 42 (term -> term MULT factor .)
    OU              shift and go to state 58


state 82

    (48) factor -> factor OU expr .
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    OU              reduce using rule 48 (factor -> factor OU expr .)
    MINUS           reduce using rule 48 (factor -> factor OU expr .)
    PLUS            reduce using rule 48 (factor -> factor OU expr .)
    MULT            reduce using rule 48 (factor -> factor OU expr .)
    ;               reduce using rule 48 (factor -> factor OU expr .)
    ET              reduce using rule 48 (factor -> factor OU expr .)
    DIV             reduce using rule 48 (factor -> factor OU expr .)
    MODULO          reduce using rule 48 (factor -> factor OU expr .)
    )               reduce using rule 48 (factor -> factor OU expr .)
    ,               reduce using rule 48 (factor -> factor OU expr .)
    COMPARATEUR     shift and go to state 51


state 83

    (45) factor -> LIRE ( ) .
    OU              reduce using rule 45 (factor -> LIRE ( ) .)
    MINUS           reduce using rule 45 (factor -> LIRE ( ) .)
    PLUS            reduce using rule 45 (factor -> LIRE ( ) .)
    MULT            reduce using rule 45 (factor -> LIRE ( ) .)
    ;               reduce using rule 45 (factor -> LIRE ( ) .)
    ET              reduce using rule 45 (factor -> LIRE ( ) .)
    DIV             reduce using rule 45 (factor -> LIRE ( ) .)
    COMPARATEUR     reduce using rule 45 (factor -> LIRE ( ) .)
    MODULO          reduce using rule 45 (factor -> LIRE ( ) .)
    )               reduce using rule 45 (factor -> LIRE ( ) .)
    ,               reduce using rule 45 (factor -> LIRE ( ) .)


state 84

    (50) factor -> ( expr ) .
    OU              reduce using rule 50 (factor -> ( expr ) .)
    MINUS           reduce using rule 50 (factor -> ( expr ) .)
    PLUS            reduce using rule 50 (factor -> ( expr ) .)
    MULT            reduce using rule 50 (factor -> ( expr ) .)
    ;               reduce using rule 50 (factor -> ( expr ) .)
    ET              reduce using rule 50 (factor -> ( expr ) .)
    DIV             reduce using rule 50 (factor -> ( expr ) .)
    COMPARATEUR     reduce using rule 50 (factor -> ( expr ) .)
    MODULO          reduce using rule 50 (factor -> ( expr ) .)
    )               reduce using rule 50 (factor -> ( expr ) .)
    ,               reduce using rule 50 (factor -> ( expr ) .)


state 85

    (28) appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .
    MINUS           reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    PLUS            reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    MULT            reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    ;               reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    ET              reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    DIV             reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    COMPARATEUR     reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    MODULO          reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    )               reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    ,               reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)
    OU              reduce using rule 28 (appel_fonction_expr_without_parm -> IDENTIFIANT ( ) .)


state 86

    (26) appel_fonction_expr -> IDENTIFIANT ( arg_list . )
    (55) arg_list -> arg_list . , expr
    )               shift and go to state 97
    ,               shift and go to state 73


state 87

    (22) boucle -> TANTQUE ( expr ) . { listeInstructions }
    {               shift and go to state 98


state 88

    (18) condition -> SI ( expr ) . { listeInstructions } suite_sinosi
    {               shift and go to state 99


state 89

    (15) ecrire -> ECRIRE ( expr ) . ;
    ;               shift and go to state 100


state 90

    (33) param -> type IDENTIFIANT .
    )               reduce using rule 33 (param -> type IDENTIFIANT .)
    ,               reduce using rule 33 (param -> type IDENTIFIANT .)


state 91

    (29) fonction_declaration -> type IDENTIFIANT ( param_list ) . { listeInstructions }
    {               shift and go to state 101


state 92

    (31) param_list -> param_list , . param
    (33) param -> . type IDENTIFIANT
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    param                          shift and go to state 102
    type                           shift and go to state 66

state 93

    (30) fonction_declaration_without_parm -> type IDENTIFIANT ( ) { . listeInstructions }
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    type                           shift and go to state 15
    listeInstructions              shift and go to state 103
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14

state 94

    (16) declaration -> type IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)
    RETOURNER       reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)
    TANTQUE         reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)
    SI              reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)
    ENT             reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)
    BOOLEEN         reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)
    $end            reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)
    }               reduce using rule 16 (declaration -> type IDENTIFIANT = expr ; .)


state 95

    (25) appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .
    IDENTIFIANT     reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    RETOURNER       reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    TANTQUE         reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    SI              reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    ECRIRE          reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    ENT             reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    BOOLEEN         reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    $end            reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)
    }               reduce using rule 25 (appel_fonction_instr -> IDENTIFIANT ( arg_list ) ; .)


state 96

    (55) arg_list -> arg_list , expr .
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    )               reduce using rule 55 (arg_list -> arg_list , expr .)
    ,               reduce using rule 55 (arg_list -> arg_list , expr .)
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 97

    (26) appel_fonction_expr -> IDENTIFIANT ( arg_list ) .
    MINUS           reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    PLUS            reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    MULT            reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    ;               reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    ET              reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    DIV             reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    COMPARATEUR     reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    MODULO          reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    )               reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    ,               reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)
    OU              reduce using rule 26 (appel_fonction_expr -> IDENTIFIANT ( arg_list ) .)


state 98

    (22) boucle -> TANTQUE ( expr ) { . listeInstructions }
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    listeInstructions              shift and go to state 104
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 99

    (18) condition -> SI ( expr ) { . listeInstructions } suite_sinosi
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    listeInstructions              shift and go to state 105
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 100

    (15) ecrire -> ECRIRE ( expr ) ; .
    IDENTIFIANT     reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)
    RETOURNER       reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)
    TANTQUE         reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)
    SI              reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)
    ENT             reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)
    BOOLEEN         reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)
    }               reduce using rule 15 (ecrire -> ECRIRE ( expr ) ; .)


state 101

    (29) fonction_declaration -> type IDENTIFIANT ( param_list ) { . listeInstructions }
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    type                           shift and go to state 15
    listeInstructions              shift and go to state 106
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14

state 102

    (31) param_list -> param_list , param .
    )               reduce using rule 31 (param_list -> param_list , param .)
    ,               reduce using rule 31 (param_list -> param_list , param .)


state 103

    (30) fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions . }
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    }               shift and go to state 107
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    type                           shift and go to state 15
    instruction                    shift and go to state 23
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14

state 104

    (22) boucle -> TANTQUE ( expr ) { listeInstructions . }
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    }               shift and go to state 108
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    instruction                    shift and go to state 23
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 105

    (18) condition -> SI ( expr ) { listeInstructions . } suite_sinosi
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    }               shift and go to state 109
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    instruction                    shift and go to state 23
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 106

    (29) fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions . }
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    }               shift and go to state 110
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    type                           shift and go to state 15
    instruction                    shift and go to state 23
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14

state 107

    (30) fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .
    IDENTIFIANT     reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    RETOURNER       reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    TANTQUE         reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    SI              reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    ECRIRE          reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    ENT             reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    BOOLEEN         reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    $end            reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)
    }               reduce using rule 30 (fonction_declaration_without_parm -> type IDENTIFIANT ( ) { listeInstructions } .)


state 108

    (22) boucle -> TANTQUE ( expr ) { listeInstructions } .
    IDENTIFIANT     reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    RETOURNER       reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    TANTQUE         reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    SI              reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    ECRIRE          reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    ENT             reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    BOOLEEN         reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    $end            reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)
    }               reduce using rule 22 (boucle -> TANTQUE ( expr ) { listeInstructions } .)


state 109

    (18) condition -> SI ( expr ) { listeInstructions } . suite_sinosi
    (19) suite_sinosi -> .
    (20) suite_sinosi -> . SINON SI ( expr ) { listeInstructions } suite_sinosi
    (21) suite_sinosi -> . SINON { listeInstructions }
    IDENTIFIANT     reduce using rule 19 (suite_sinosi -> .)
    RETOURNER       reduce using rule 19 (suite_sinosi -> .)
    TANTQUE         reduce using rule 19 (suite_sinosi -> .)
    SI              reduce using rule 19 (suite_sinosi -> .)
    ECRIRE          reduce using rule 19 (suite_sinosi -> .)
    ENT             reduce using rule 19 (suite_sinosi -> .)
    BOOLEEN         reduce using rule 19 (suite_sinosi -> .)
    $end            reduce using rule 19 (suite_sinosi -> .)
    }               reduce using rule 19 (suite_sinosi -> .)
    SINON           shift and go to state 112

    suite_sinosi                   shift and go to state 111

state 110

    (29) fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .
    IDENTIFIANT     reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    RETOURNER       reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    TANTQUE         reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    SI              reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    ECRIRE          reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    ENT             reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    BOOLEEN         reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    $end            reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)
    }               reduce using rule 29 (fonction_declaration -> type IDENTIFIANT ( param_list ) { listeInstructions } .)


state 111

    (18) condition -> SI ( expr ) { listeInstructions } suite_sinosi .
    IDENTIFIANT     reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    RETOURNER       reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    TANTQUE         reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    SI              reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    ECRIRE          reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    ENT             reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    BOOLEEN         reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    $end            reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)
    }               reduce using rule 18 (condition -> SI ( expr ) { listeInstructions } suite_sinosi .)


state 112

    (20) suite_sinosi -> SINON . SI ( expr ) { listeInstructions } suite_sinosi
    (21) suite_sinosi -> SINON . { listeInstructions }
    SI              shift and go to state 113
    {               shift and go to state 114


state 113

    (20) suite_sinosi -> SINON SI . ( expr ) { listeInstructions } suite_sinosi
    (               shift and go to state 115


state 114

    (21) suite_sinosi -> SINON { . listeInstructions }
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    listeInstructions              shift and go to state 116
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 115

    (20) suite_sinosi -> SINON SI ( . expr ) { listeInstructions } suite_sinosi
    (34) expr -> . expr ET expr
    (35) expr -> . expr DIV term
    (36) expr -> . expr COMPARATEUR expr
    (37) expr -> . expr MODULO term
    (38) expr -> . term
    (39) term -> . term MINUS factor
    (40) term -> . term PLUS factor
    (41) term -> . factor
    (42) term -> . term MULT factor
    (43) term -> . appel_fonction_expr_without_parm
    (44) term -> . appel_fonction_expr
    (45) factor -> . LIRE ( )
    (46) factor -> . MINUS factor
    (47) factor -> . NON expr
    (48) factor -> . factor OU expr
    (49) factor -> . IDENTIFIANT
    (50) factor -> . ( expr )
    (51) factor -> . BOOLEEN_LITERAL
    (52) factor -> . ENTIER
    (28) appel_fonction_expr_without_parm -> . IDENTIFIANT ( )
    (26) appel_fonction_expr -> . IDENTIFIANT ( arg_list )
    LIRE            shift and go to state 33
    MINUS           shift and go to state 29
    NON             shift and go to state 35
    IDENTIFIANT     shift and go to state 36
    (               shift and go to state 34
    BOOLEEN_LITERAL shift and go to state 37
    ENTIER          shift and go to state 38

    expr                           shift and go to state 117
    term                           shift and go to state 28
    factor                         shift and go to state 30
    appel_fonction_expr_without_parm shift and go to state 31
    appel_fonction_expr            shift and go to state 32

state 116

    (21) suite_sinosi -> SINON { listeInstructions . }
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    }               shift and go to state 118
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    instruction                    shift and go to state 23
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 117

    (20) suite_sinosi -> SINON SI ( expr . ) { listeInstructions } suite_sinosi
    (34) expr -> expr . ET expr
    (35) expr -> expr . DIV term
    (36) expr -> expr . COMPARATEUR expr
    (37) expr -> expr . MODULO term
    )               shift and go to state 119
    ET              shift and go to state 49
    DIV             shift and go to state 50
    COMPARATEUR     shift and go to state 51
    MODULO          shift and go to state 52


state 118

    (21) suite_sinosi -> SINON { listeInstructions } .
    IDENTIFIANT     reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)
    RETOURNER       reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)
    TANTQUE         reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)
    SI              reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)
    ECRIRE          reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)
    ENT             reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)
    BOOLEEN         reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)
    $end            reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)
    }               reduce using rule 21 (suite_sinosi -> SINON { listeInstructions } .)


state 119

    (20) suite_sinosi -> SINON SI ( expr ) . { listeInstructions } suite_sinosi
    {               shift and go to state 120


state 120

    (20) suite_sinosi -> SINON SI ( expr ) { . listeInstructions } suite_sinosi
    (3) listeInstructions -> . instruction
    (4) listeInstructions -> . listeInstructions instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    listeInstructions              shift and go to state 121
    instruction                    shift and go to state 4
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 121

    (20) suite_sinosi -> SINON SI ( expr ) { listeInstructions . } suite_sinosi
    (4) listeInstructions -> listeInstructions . instruction
    (5) instruction -> . fonction_declaration
    (6) instruction -> . fonction_declaration_without_parm
    (7) instruction -> . appel_fonction_instr_without_parm
    (8) instruction -> . appel_fonction_instr
    (9) instruction -> . retourner
    (10) instruction -> . boucle
    (11) instruction -> . condition
    (12) instruction -> . affectation
    (13) instruction -> . declaration
    (14) instruction -> . ecrire
    (29) fonction_declaration -> . type IDENTIFIANT ( param_list ) { listeInstructions }
    (30) fonction_declaration_without_parm -> . type IDENTIFIANT ( ) { listeInstructions }
    (27) appel_fonction_instr_without_parm -> . IDENTIFIANT ( ) ;
    (25) appel_fonction_instr -> . IDENTIFIANT ( arg_list ) ;
    (23) retourner -> . RETOURNER expr ;
    (24) retourner -> . retourner
    (22) boucle -> . TANTQUE ( expr ) { listeInstructions }
    (18) condition -> . SI ( expr ) { listeInstructions } suite_sinosi
    (17) affectation -> . IDENTIFIANT = expr ;
    (16) declaration -> . type IDENTIFIANT = expr ;
    (15) ecrire -> . ECRIRE ( expr ) ;
    (53) type -> . ENT
    (54) type -> . BOOLEEN
    }               shift and go to state 122
    IDENTIFIANT     shift and go to state 16
    RETOURNER       shift and go to state 17
    TANTQUE         shift and go to state 18
    SI              shift and go to state 19
    ECRIRE          shift and go to state 20
    ENT             shift and go to state 21
    BOOLEEN         shift and go to state 22

    instruction                    shift and go to state 23
    fonction_declaration           shift and go to state 5
    fonction_declaration_without_parm shift and go to state 6
    appel_fonction_instr_without_parm shift and go to state 7
    appel_fonction_instr           shift and go to state 8
    retourner                      shift and go to state 9
    boucle                         shift and go to state 10
    condition                      shift and go to state 11
    affectation                    shift and go to state 12
    declaration                    shift and go to state 13
    ecrire                         shift and go to state 14
    type                           shift and go to state 15

state 122

    (20) suite_sinosi -> SINON SI ( expr ) { listeInstructions } . suite_sinosi
    (19) suite_sinosi -> .
    (20) suite_sinosi -> . SINON SI ( expr ) { listeInstructions } suite_sinosi
    (21) suite_sinosi -> . SINON { listeInstructions }
    IDENTIFIANT     reduce using rule 19 (suite_sinosi -> .)
    RETOURNER       reduce using rule 19 (suite_sinosi -> .)
    TANTQUE         reduce using rule 19 (suite_sinosi -> .)
    SI              reduce using rule 19 (suite_sinosi -> .)
    ECRIRE          reduce using rule 19 (suite_sinosi -> .)
    ENT             reduce using rule 19 (suite_sinosi -> .)
    BOOLEEN         reduce using rule 19 (suite_sinosi -> .)
    $end            reduce using rule 19 (suite_sinosi -> .)
    }               reduce using rule 19 (suite_sinosi -> .)
    SINON           shift and go to state 112

    suite_sinosi                   shift and go to state 123

state 123

    (20) suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .
    IDENTIFIANT     reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    RETOURNER       reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    TANTQUE         reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    SI              reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    ECRIRE          reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    ENT             reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    BOOLEEN         reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    $end            reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)
    }               reduce using rule 20 (suite_sinosi -> SINON SI ( expr ) { listeInstructions } suite_sinosi .)


Conflicts:

shift/reduce conflict for MINUS in state 28 resolved as shift
shift/reduce conflict for PLUS in state 28 resolved as shift
shift/reduce conflict for MULT in state 28 resolved as shift
shift/reduce conflict for OU in state 30 resolved as shift
reduce/reduce conflict in state 9 resolved using rule instruction -> retourner
rejected rule (retourner -> retourner) in state 9
Rule (retourner -> retourner) is never reduced